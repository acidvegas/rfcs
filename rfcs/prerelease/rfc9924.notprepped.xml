<?xml version='1.0' encoding='utf-8'?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-lim-apv-09" number="9924" category="info" submissionType="independent" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" xml:lang="en" version="3">

  <front>
    <title abbrev="APV">Advanced Professional Video</title>
    <seriesInfo name="RFC" value="9924"/>
    <author initials="Y." surname="Lim" fullname="Youngkwon Lim">
      <organization>Samsung Electronics</organization>
      <address>
        <postal>
          <street>6105 Tennyson Pkwy, Ste 300</street>
          <city>Plano</city><region>TX</region>
          <code>75024</code>
          <country>United States of America</country>
        </postal>
        <email>yklwhite@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Park" fullname="Minwoo Park">
      <organization>Samsung Electronics</organization>
      <address>
        <postal>
          <street>34, Seongchon-gil, Seocho-gu</street>
          <city>Seoul</city>
          <code>3573</code>
          <country>Republic of Korea</country>
        </postal>
        <email>m.w.park@samsung.com</email>
      </address>
    </author>
    <author initials="M." surname="Budagavi" fullname="Madhukar Budagavi">
      <organization>Samsung Electronics</organization>
      <address>
        <postal>
          <street>6105 Tennyson Pkwy, Ste 300</street>
          <city>Plano</city><region>TX</region>
          <code>75024</code>
          <country>United States of America</country>
        </postal>
        <email>m.budagavi@samsung.com</email>
      </address>
    </author>
    <author initials="R." surname="Joshi" fullname="Rajan Joshi">
      <organization>Samsung Electronics</organization>
      <address>
        <postal>
          <street>11488 Tree Hollow Ln</street>
          <city>San Diego</city><region>CA</region>
          <code>92128</code>
          <country>United States of America</country>
        </postal>
        <email>rajan_joshi@ieee.org</email>
      </address>
    </author>
    <author initials="K." surname="Choi" fullname="Kwang Pyo Choi">
      <organization>Samsung Electronics</organization>
      <address>
        <postal>
          <street>34 Seongchon-gil Seocho-gu</street>
          <city>Seoul</city>
          <code>3573</code>
          <country>Republic of Korea</country>
        </postal>
        <email>kwangpyo.choi@gmail.com</email>
      </address>
    </author>
    <date year="2026" month="February"/>

    <keyword>mezzanine codec</keyword>
    <keyword>visually lossless compression</keyword>
    <keyword>APV</keyword>

    <abstract>
<t>This document describes the bitstream format of Advanced Professional Video (APV) and its decoding process. APV is a professional video codec providing visually lossless compression mainly for recording and post production.</t>
    </abstract>
  </front>
  <middle>
    <?line 129?>

<section anchor="introduction">
      <name>Introduction</name>
      <t>This document defines the bitstream format  and decoding process for the Advanced Professional Video (APV) codec. The APV codec is a professional video codec that was developed in response to the need for professional-level, high-quality video recording and post production. The primary purpose of the APV codec is for use in professional video recording and editing workflows for various types of content.  This specification is neither the product of the IETF nor a consensus view of the community.</t>
      <t>The APV codec supports the following features:</t>
      <ul spacing="normal">
        <li>
          <t>Perceptually lossless video quality that is close to the original, uncompressed quality;</t>
        </li>
        <li>
          <t>Low complexity and high throughput intra frame only coding without inter frame coding;</t>
        </li>

        <li>
      <t>Intra frame coding without prediction between pixel values but with prediction between transformed values for low delay encoding;</t>
        </li>
        <li>
          <t>High bit rates of up to a few Gbps for 2K, 4K, and 8K resolution content, enabled by a lightweight entropy coding scheme;</t>
        </li>
        <li>
          <t>Frame tiling for immersive content and for enabling parallel encoding and decoding;</t>
        </li>
        <li>
          <t>Various chroma sampling formats from 4:0:0 to 4:4:4:4, and bit depths from 10 to 16 (Note: Only the profiles supporting 10 bits and 12 bits are currently defined);</t>
        </li>
        <li>
          <t>The ability to decode and re-encode multiple times without severe visual quality degradation; and</t>
        </li>
        <li>
          <t>Various metadata including HDR10/10+ and user-defined formats.</t>
        </li>
      </ul>
    </section>
    <section anchor="terms">
      <name>Terms</name>
      <section anchor="terms-and-definitions">
        <name>Terms and Definitions</name>
        <dl spacing="normal" newline="false">
          <dt>access unit (AU):</dt><dd>a collection of primitive bitstream
          units (PBU) including various types of frames, metadata, filler, and
          access unit information, associated with a specific time</dd>
          <dt>band:</dt><dd>a defined set of constraints on the value of the
          maximum coded data rate of each level</dd>
          <dt>block:</dt><dd>MxN (M-column by N-row) array of samples, or an MxN array of transform coefficients</dd>
          <dt>byte-aligned:</dt><dd>a position in a bitstream that is an
          integer multiple of 8 bits from the position of the first bit in the
          bitstream</dd>
          <dt>chroma:</dt><dd>a sample array or single sample representing one
          of the two color difference signals related to the primary colors,
          represented by the symbols Cb and Cr in 4:2:2 or 4:4:4 color
          format</dd>
          <dt>coded frame:</dt><dd>a coded representation of a frame
          containing all macroblocks of the frame</dd>
          <dt>coded representation:</dt><dd>a data element as represented in its coded form</dd>
          <dt>component:</dt><dd>an array or a single sample from one of the
          three arrays (luma and two chroma) that compose a frame in 4:2:2, or
          4:4:4 color format, or an array or a single sample from an array
          that compose a frame in 4:0:0 color format, or an array or a single
          sample from one of the four arrays that compose a frame in 4:4:4:4
          color format.</dd>
          <dt>decoded frame:</dt><dd>a frame derived by decoding a coded frame</dd>
          <dt>decoder:</dt><dd>an embodiment of a decoding process</dd>
          <dt>decoding process:</dt><dd>a process specified that reads a
          bitstream and derives decoded frames from it</dd>
          <dt>encoder:</dt><dd>an embodiment of an encoding process</dd>
          <dt>encoding process:</dt><dd>a process that produces a bitstream conforming to this document</dd>
          <dt>flag:</dt><dd>a variable or single-bit syntax element that can take one of the two possible values: 0 and 1</dd>
          <dt>frame:</dt><dd>an array of luma samples and two corresponding arrays of chroma samples in 4:2:2 and 4:4:4 color format, or an array of samples in 4:0:0 color format, or four arrays of samples in 4:4:4:4 color format</dd>
          <dt>level:</dt><dd>a defined set of constraints on the values that are taken by the syntax elements and variables of this document, or the value of a transform coefficient prior to scaling</dd>
          <dt>luma:</dt><dd>a sample array or single sample representing the monochrome signal related to the primary colors, represented by the symbol or subscript Y or L</dd>
          <dt>macroblock (MB):</dt><dd>a square block of luma samples and two corresponding blocks of chroma samples of a frame in 4:2:2 or 4:4:4 color format, or a square block of samples of a frame in 4:0:0 color format, or four square blocks of samples of a frame in 4:4:4:4 color format</dd>
          <dt>metadata:</dt><dd>data describing various characteristics related to a bitstream without directly affecting the decoding process of it.</dd>
          <dt>partitioning:</dt><dd>a division of a set into subsets such that each element of the set is in exactly one of the subsets</dd>
          <dt>prediction:</dt><dd>an embodiment of the prediction process</dd>
          <dt>prediction process:</dt><dd>use of a predictor to provide an estimate of the data element currently being decoded</dd>
          <dt>predictor:</dt><dd>a combination of specified values or previously decoded data elements used in the decoding process of subsequent data elements</dd>
          <dt>primitive bitstream unit (PBU):</dt><dd>a data structure to construct an access unit with frame and metadata</dd>
          <dt>profile:</dt><dd>a specified subset of the syntax of this document</dd>
          <dt>quantization parameter (QP):</dt><dd>a variable used by the decoding process for the scaling value of transform coefficients</dd>
          <dt>raster scan:</dt><dd>a mapping of a rectangular two-dimensional pattern to a one-dimensional pattern such that the first entries in the one-dimensional pattern are from the top row of the two-dimensional pattern scanned from left to right, followed by the second, third, etc., rows of the pattern each scanned from left to right</dd>
          <dt>raw bitstream:</dt><dd>an encapsulation of a sequence of access units where a field indicating the size of an access unit precedes each access unit as defined in <xref target="appendix-rawbitstream"/></dd>
          <dt>source:</dt><dd>a term used to describe the video material or some of its attributes before the encoding process</dd>
          <dt>syntax element:</dt><dd>an element of data represented in the bitstream</dd>
          <dt>syntax structure:</dt><dd>zero or more syntax elements present together in a bitstream in a specified order</dd>
          <dt>tile:</dt><dd>a rectangular region of MBs within a particular tile column and a particular tile row in a frame</dd>
          <dt>tile column:</dt><dd>a rectangular region of MBs having a height equal to the height of the frame and width specified by syntax elements in the frame header</dd>
          <dt>tile row:</dt><dd>a rectangular region of MBs having a height specified by syntax elements in the frame header and a width equal to the width of the frame</dd>
          <dt>tile scan:</dt><dd>a specific sequential ordering of MBs partitioning a frame in which the MBs are ordered consecutively in MB raster scan in a tile and the tiles in a frame are ordered consecutively in a raster scan of the tiles of the frame</dd>
          <dt>transform coefficient:</dt><dd>a scalar quantity, considered to be in a frequency domain, that is associated with a particular one-dimensional or two-dimensional index</dd>
        </dl>
      </section>
      <section anchor="abbreviated-terms">
        <name>Abbreviated Terms</name>
        <dl spacing="normal" newline="false">
          <dt>LSB:</dt><dd>least significant bit</dd>
          <dt>MSB:</dt><dd>most significant bit</dd>
          <dt>RGB:</dt><dd>Red, Green and Blue</dd>
        </dl>
      </section>
    </section>
    <section anchor="conventions">
      <name>Conventions Used in This Document</name>
      <section anchor="general">
        <name>General</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref
    target="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
        </t>
      </section>
      <section anchor="operators">
        <name>Operators</name>
        <t>The operators and the order of precedence are the same as used in the C programming language <xref target="ISO9899"/>. However, there are some exceptions for the operators described in the <xref target="arith-operator"/> and <xref target="bit-operator"/>, which follows widely used industry practices for video codecs.</t>
        <section anchor="arith-operator">
          <name>Arithmetic Operators</name>
          <dl spacing="normal" newline="true">
            <dt>//</dt>
	    <dd>an integer division with rounding of the result toward
	    zero. For example, 7//4 and -7//-4 are rounded to 1 and -7//4 and
	    7//-4 are rounded to -1</dd>
            <dt>/ or div(x,y)</dt>
	    <dd>a division in mathematical equations where no truncation or rounding is intended</dd>
            <dt>min(x,y)</dt>
	    <dd>the minimum value of the values x and y</dd>
            <dt>max(x,y)</dt>
	    <dd>the maximum value of the values x and y</dd>
            <dt>ceil(x)</dt>
	    <dd>the smallest integer value that is larger than or equal to x</dd>
            <dt>clip(x,y,z)</dt>
	    <dd>clip(x,y,z)=max(x,min(z,y))</dd>
            <dt>sum (i=x, y, f(i))</dt>
	    <dd>a summation of f(i) with i taking all integer values from x up to and including y</dd>
            <dt>log2(x)</dt>
	    <dd>the base-2 logarithm of x</dd>
          </dl>
        </section>
        <section anchor="bit-operator">
          <name>Bitwise Operators</name>
          <dl spacing="normal" newline="true">
            <dt>&amp; (bitwise "and")</dt><dd>When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on arguments with unequal bit depths, the bit depths are equalized by adding zeros in significant positions to the argument with lower bit depth.</dd>
            <dt>| (bitwise "or")</dt><dd>When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on arguments with unequal bit depths, the bit depths are equalized by adding zeros in significant positions to the argument with lower bit depth.</dd>
            <dt>x &gt;&gt; y</dt><dd>arithmetic right shift of a two's complement integer representation of x by y binary digits. This function is defined only for non-negative integer values of y. Bits shifted into the most significant bits (MSBs) as a result of the right shift have a value equal to the MSB of x prior to the shift operation.</dd>
            <dt>x &lt;&lt; y</dt><dd>arithmetic left shift of a two's complement integer representation of x by y binary digits. This function is defined only for non-negative integer values of y. Bits shifted into the least significant bits (LSBs) as a result of the left shift have a value equal to 0.</dd>
          </dl>
        </section>
      </section>
      <section anchor="range-notation">
        <name>Range Notation</name>
        <dl spacing="normal" newline="true">
          <dt>x = y..z</dt>
          <dd>x takes on integer values starting from y to z, inclusive, with x, y, and z being integer numbers and z being greater than y.</dd>
        </dl>

        <section anchor="order-of-operations-precedence">
          <name>Order of Operations Precedence</name>
          <t>When order of precedence is not indicated explicitly by use of parentheses, operations are evaluated in the following order.</t>
          <ul spacing="normal">
            <li>
              <t>Operations of a higher precedence are evaluated before any operation of a lower precedence. <xref target="_table-operation_order"/> specifies the precedence of operations from highest to lowest; operations closer to the top of the table indicate a higher precedence.</t>
            </li>
            <li>
              <t>Operations of the same precedence are evaluated sequentially from left to right.</t>
            </li>
          </ul>
          <table anchor="_table-operation_order">
            <name>Operation precedence from highest (top of the table) to lowest (bottom of the table)</name>
            <thead>
              <tr>
                <th align="left">operations (with operands x, y, and z)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">"x++", "x--"</td>
              </tr>
              <tr>
                <td align="left">"!x", "-x" (as a unary prefix operator)</td>
              </tr>
              <tr>
                <td align="left">x^y (power)</td>
              </tr>
              <tr>
                <td align="left">"x * y", "x / y", "x // y", "x % y"</td>
              </tr>
              <tr>
                <td align="left">"x + y", "x - y", "sum (i=x, y, f(i))"</td>
              </tr>
              <tr>
                <td align="left">"x &lt;&lt; y", "x &gt;&gt; y"</td>
              </tr>
              <tr>
                <td align="left">"x &lt; y", "x &lt;= y", "x &gt; y", "x &gt;= y"</td>
              </tr>
              <tr>
                <td align="left">"x == y", "x != y"</td>
              </tr>
              <tr>
                <td align="left">"x &amp; y"</td>
              </tr>
              <tr>
                <td align="left">"x | y"</td>
              </tr>
              <tr>
                <td align="left">"x &amp;&amp; y"</td>
              </tr>
              <tr>
                <td align="left">"x || y"</td>
              </tr>
              <tr>
                <td align="left">"x ? y : z"</td>
              </tr>
              <tr>
                <td align="left">"x..y"</td>
              </tr>
              <tr>
                <td align="left">"x = y", "x += y", "x -= y"</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="variables-syntax-elements-and-tables">
        <name>Variables, Syntax Elements, and Tables</name>
        <t>Each syntax element is described by its name in all lowercase letters and its type is provided next to the syntax code in each row. Each syntax element and multi-byte integers are written in big endian format. The decoding process behaves according to the value of the syntax element and to the values of previously decoded syntax elements.</t>
        <t>In some cases, the syntax tables may use the values of other variables derived from syntax elements values. Such variables appear in the syntax tables or text, named by a mixture of lower case and uppercase letters and without any underscore characters. Variables with names starting with an uppercase letter are derived for the decoding of the current syntax structure and all dependent syntax structures. Variables with names starting with an uppercase letter may be used in the decoding process for later syntax structures without mentioning the originating syntax structure of the variable. Variables with names starting with a lowercase letter are only used within the section in which they are derived.</t>
        <t>Functions that specify properties of the current position in the bitstream are referred to as syntax functions. These functions are specified in <xref target="syntax-func"/> and assume the existence of a bitstream pointer with an indication of the position of the next bit to be read by the decoding process from the bitstream.</t>
        <t>A one-dimensional array is referred to as a list. A two-dimensional array is referred to as a matrix. Arrays can either be syntax elements or variables. Square brackets are used for the indexing of arrays. In reference to a visual depiction of a matrix, the first square bracket is used as a column (horizontal) index and the second square bracket is used as a row (vertical) index.</t>
        <t>A specification of values of the entries in rows and columns of an array may be denoted by {{...}{...}}, where each inner pair of brackets specifies the values of the elements within a row in increasing column order and the rows are ordered in increasing row order. Thus, setting a matrix s equal to {{1 6}{4 9}} specifies that s[0][0] is set equal to 1, s[1][0] is set equal to 6, s[0][1] is set equal to 4, and s[1][1] is set equal to 9.</t>
        <t>Binary notation is indicated by enclosing the string of bit values in single quote marks. For example, '0b01000001' represents an eight-bit string having only its second and its last bits (counted from the most to the least significant bit) equal to 1.</t>
        <t>Hexadecimal notation, indicated by prefixing the hexadecimal number by "0x", may be used instead of binary notation when the number of bits is an integer multiple of 4. For example, 0x41 represents an eight-bit string having only its second and its last bits (counted from the most to the least significant bit) equal to 1.</t>
        <t>A value equal to 0 represents a FALSE condition in a test statement. The value TRUE is represented by any value different from zero.</t>
      </section>
      <section anchor="processes">
        <name>Processes</name>
        <t>Processes are used to describe the decoding of syntax elements. A process has a separate specification and invoking.
When invoking a process, the assignment of variables is specified as follows:</t>
        <ul spacing="normal">
          <li>
            <t>If the variables at the invoking and the process specification do not have the same name, the variables are explicitly assigned to lower case input or output variables of the process specification.</t>
          </li>
          <li>
            <t>Otherwise (the variables at the invoking and the process specification have the same name), the assignment is implied.</t>
          </li>
        </ul>
        <t>In the specification of a process, a specific coding block is referred to by the variable name having a value equal to the address of the specific coding block.</t>
      </section>
    </section>
    <section anchor="Formats">
      <name>Formats and Processes Used in This Document</name>
      <section anchor="bitstream-formats">
        <name>Bitstream Formats</name>
        <t>This section specifies the bitstream format of the Advanced Professional Video (APV) codec.</t>
        <t>A raw bitstream format consists of a sequence of AUs where the field indicating the size of access units precedes each of them. The raw bitstream format is specified in <xref target="appendix-rawbitstream"/>.</t>
      </section>
      <section anchor="source-decoded-and-output-frame-formats">
        <name>Source, Decoded, and Output Frame Formats</name>
        <t>This section specifies the relationship between the source and decoded frames.</t>
        <t>The video source that is represented by the bitstream is a sequence of frames.</t>
        <t>Source and decoded frames are each comprised of one or more sample arrays:</t>
        <ul spacing="normal">
          <li>
            <t>Monochrome (for example, Luma only)</t>
          </li>
          <li>
            <t>Luma and two chroma (for example, YCbCr or YCgCo as specified in <xref target="H273"/>).</t>
          </li>
          <li>
            <t>Green, blue, and red (GBR, also known as RGB).</t>
          </li>
          <li>
            <t>Arrays representing other unspecified tri-stimulus color samplings (for example, YZX, also known as XYZ as specified in <xref target="CIE15"/>).</t>
          </li>
          <li>
            <t>Arrays representing other unspecified four color samplings</t>
          </li>
        </ul>
        <t>For the convenience of notation and terminology in this document, the variables and terms associated with these arrays can be referred to as luma and chroma regardless of the actual color representation method in use.</t>

        <t>The values of the variables SubWidthC, SubHeightC, and NumComps depend on the chroma format sampling structure as specified in <xref target="_table-chroma_format_idc"/>. The chroma format sampling structure is signaled through chroma_format_idc. Other values of chroma_format_idc, SubWidthC, SubHeightC, and NumComps may be specified in future versions of this document.</t>
        <table anchor="_table-chroma_format_idc">
          <name>SubWidthC, SubHeightC, and NumComps values derived from chroma_format_idc</name>
          <thead>
            <tr>
              <th align="center">chroma_format_idc</th>
              <th align="center">Chroma format</th>
              <th align="center">SubWidthC</th>
              <th align="center">SubHeightC</th>
              <th align="center">NumComps</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">0</td>
              <td align="center">4:0:0</td>
              <td align="center">1</td>
              <td align="center">1</td>
              <td align="center">1</td>
            </tr>
            <tr>
              <td align="center">1</td>
              <td align="center">reserved</td>
              <td align="center">reserved</td>
              <td align="center">reserved</td>
              <td align="center">reserved</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="center">4:2:2</td>
              <td align="center">2</td>
              <td align="center">1</td>
              <td align="center">3</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="center">4:4:4</td>
              <td align="center">1</td>
              <td align="center">1</td>
              <td align="center">3</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="center">4:4:4:4</td>
              <td align="center">1</td>
              <td align="center">1</td>
              <td align="center">4</td>
            </tr>
            <tr>
              <td align="center">5..7</td>
              <td align="center">reserved</td>
              <td align="center">reserved</td>
              <td align="center">reserved</td>
              <td align="center">reserved</td>
            </tr>
          </tbody>
        </table>
        <t>In 4:0:0 sampling, there is only one sample array that can be considered as the luma array.</t>
        <t>In 4:2:2 sampling, each of the two chroma arrays has the same height and half the width of the luma array.</t>
        <t>In 4:4:4 sampling and 4:4:4:4 sampling, all the sample arrays have the same height and width as the luma array.</t>
        <t>The number of bits necessary for the representation of each of the samples in the luma and chroma arrays in a video sequence is in the range of 10 to 16, inclusive.</t>
        <t>When the value of chroma_format_idc is equal to 2, the chroma samples are co-sited with the corresponding luma samples; the nominal locations in a frame are as shown in <xref target="_figure-format420"/>.</t>
        <figure anchor="_figure-format420">
          <name>Nominal vertical and horizontal locations of 4:2:2 luma and chroma samples in a frame</name>
          <artwork><![CDATA[
              & * & * & * & * & * ...

              & * & * & * & * & * ...

              & * & * & * & * & * ...

              & * & * & * & * & * ...

                       ...

& - location where both luma and chroma sample exist
* - location where only luma sample exist]]></artwork>
        </figure>
        <t>For each frame, when the value of chroma_format_idc is equal to 3 or 4, all of the array samples are co-sited; the nominal locations in a frame are as shown in <xref target="_figure-format444"/>.</t>
        <figure anchor="_figure-format444">
          <name>Nominal vertical and horizontal locations of 4:4:4 and 4:4:4:4 luma and chroma samples in a frame</name>
          <artwork><![CDATA[
              & & & & & & & & & & ...

              & & & & & & & & & & ...

              & & & & & & & & & & ...

              & & & & & & & & & & ...

                       ...

& - location where both luma and chroma sample exist]]></artwork>
        </figure>
        <t>Samples are processed in units of MBs. The variables MbWidth and MbHeight, which specify the width and height of the luma arrays for each MB, are defined as follows:</t>
        <ul spacing="normal">
          <li>
            <t>MbWidth = 16</t>
          </li>
          <li>
            <t>MbHeight = 16</t>
          </li>
        </ul>
        <t>The variables MbWidthC and MbHeightC, which specify the width and height of the chroma arrays for each MB, are derived as follows:</t>
        <ul spacing="normal">
          <li>
            <t>MbWidthC = MbWidth // SubWidthC</t>
          </li>
          <li>
            <t>MbHeightC = MbHeight // SubHeightC</t>
          </li>
        </ul>
      </section>
      <section anchor="partitioning-of-a-frame">
        <name>Partitioning of a Frame</name>
        <section anchor="partitioning-of-a-frame-into-tiles">
          <name>Partitioning of a Frame into Tiles</name>
          <t>This section specifies how a frame is partitioned into tiles.</t>
          <t>A frame is divided into tiles. A tile is a group of MBs that cover a rectangular region of a frame and is processed independently of other tiles. Every tile has the same width and height, except possibly tiles at the right or bottom frame boundary when the frame width or height is not a multiple of the tile width or height, respectively. The tiles in a frame are scanned in raster order. Within a tile, the MBs are scanned in raster order. Each MB is comprised of one (MbWidth) x (MbHeight) luma array and zero, two, or three corresponding chroma sample arrays.</t>

          <t>For example, a frame is divided into 6 tiles (3 tile columns and 2 tile rows) as shown in <xref target="_figure-tile_examaple"/>. In this example, the tile size is defined as 4 column MBs and 4 row MBs. In case of the third and sixth tiles (in raster order), the tile size is 2 column MBs and 4 row MBs since the frame width is not a multiple of the tile width.</t>
          <figure anchor="_figure-tile_examaple">
            <name>Frame with 10 by 8 MBs that is partitioned into 6 tiles</name>
            <artwork><![CDATA[
+===================+===================+=========+
#    |    |    |    # MB | MB | MB | MB # MB | MB #
+-------------------+-------------------+---------+
#    |    |    |    # MB | MB | MB | MB # MB | MB #
+-----   tile  -----+-------------------+---------+
#    |    |    |    # MB | MB | MB | MB # MB | MB #
+-------------------+-------------------+---------+
#    |    |    |    # MB | MB | MB | MB # MB | MB #
+===================+===================+=========+
# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #
+-------------------+-------------------+---------+
# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #
+-------------------+-------------------+---------+
# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #
+-------------------+-------------------+---------+
# MB | MB | MB | MB # MB | MB | MB | MB # MB | MB #
+===================+===================+=========+

            #,=  tile boundary
            |,-  MB boundary
]]></artwork>
          </figure>
        </section>
        <section anchor="spatial-or-component-wise-partitioning">
          <name>Spatial or Component-Wise Partitioning</name>
          <t>The following divisions of processing elements form spatial or component-wise partitioning:</t>
          <ul spacing="normal">
            <li>
              <t>the division of each frame into components;</t>
            </li>
            <li>
              <t>the division of each frame into tile columns;</t>
            </li>
            <li>
              <t>the division of each frame into tile rows;</t>
            </li>
            <li>
              <t>the division of each tile column into tiles;</t>
            </li>
            <li>
              <t>the division of each tile row into tiles;</t>
            </li>
            <li>
              <t>the division of each tile into color components;</t>
            </li>
            <li>
              <t>the division of each tile into MBs;</t>
            </li>
            <li>
              <t>the division of each MB into blocks.</t>
            </li>
          </ul>
        </section>
      </section>
      <section anchor="scanning-processes">
        <name>Scanning Processes</name>
        <section anchor="zig-zag">
          <name>Zig-Zag Scan</name>
          <t>This process converts a two dimensional array into an one-dimensional array. The process starts at the top-left position in the block and then moves diagonally, changing direction at the edges of the block until it reaches the bottom-right position. <xref target="_figure-zz"/> shows an example of scanning order for 4x4 size block.</t>
          <figure anchor="_figure-zz">
            <name>Example of zig-zag scanning order for 4x4 block</name>
            <artwork><![CDATA[
+===================+
# 00 | 01 | 05 | 06 #
+-------------------+
# 02 | 04 | 07 | 12 #
+-------------------+
# 03 | 08 | 11 | 13 #
+-------------------+
# 09 | 10 | 14 | 15 #
+===================+
]]></artwork>
          </figure>
          <t>Inputs to this process are:</t>
          <ul spacing="normal">
            <li>
              <t>a variable blkWidth specifying the width of a block, and</t>
            </li>
            <li>
              <t>a variable blkHeight specifying the height of a block.</t>
            </li>
          </ul>
          <t>Output of this process is the array zigZagScan[sPos].</t>
          <t>The array index sPos specifies the scan position ranging from 0 to (blkWidth * blkHeight)-1. Depending on the value of blkWidth and blkHeight, the array zigZagScan is derived as follows:</t>
          <figure anchor="_figure-zzscan">
            <name>Pseudocode for zig-zag scan</name>
            <artwork><![CDATA[
pos = 0
zigZagScan[pos] = 0
pos++
for(line = 1; line < (blkWidth + blkHeight - 1); line++){
  if(line % 2){
    x = min(line, blkWidth - 1)
    y = max(0, line - (blkWidth - 1))
    while(x >=0 && y < blkHeight){
      zigZagScan[pos] = y * blkWidth + x
      pos++
      x--
      y++
    }
  }
  else{
    y = min(line, blkHeight - 1)
    x = max(0, line - (blkHeight - 1))
    while(y >= 0 && x < blkWidth){
      zigZagScan[pos] = y * blkWidth + x
      pos++
      x++
      y--
    }
  }
}]]></artwork>
          </figure>
        </section>
        <section anchor="inverse-scan">
          <name>Inverse Scan</name>
          <t>Inputs to this process are:</t>
          <ul spacing="normal">
            <li>
              <t>a variable blkWidth specifying the width of a block, and</t>
            </li>
            <li>
              <t>a variable blkHeight specifying the height of a block.</t>
            </li>
          </ul>
          <t>Output of this process is the array inverseScan[rPos].</t>
          <t>The array index rPos specifies the raster scan position ranging from 0 to (blkWidth * blkHeight)-1. Depending on the value of blkWidth and blkHeight, the array inverseScan is derived as follows:</t>
          <ul spacing="normal">
            <li>
              <t>The variable forwardScan is derived by invoking the zig-zag scan order initialization process as specified in <xref target="zig-zag"/> with input parameters blkWidth and blkHeight.</t>
            </li>
            <li>
              <t>The output variable inverseScan is derived as follows:</t>
            </li>
          </ul>
          <figure anchor="_figure-inv_zzscan">
            <name>Pseudocode for inverse zig-zag scan</name>
            <artwork><![CDATA[
for(pos = 0; pos < blkWidth * blkHeight; pos++){
  inverseScan[forwardScan[pos]] = pos
}]]></artwork>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="syntax">
      <name>Syntax and Semantics</name>
      <section anchor="method-of-specifying-syntax">
        <name>Method of Specifying Syntax</name>
        <t>The syntax tables specify a superset of the syntax of all allowed bitstreams. Note that a decoder <bcp14>MUST</bcp14> implement some means for identifying entry points into the bitstream and some means to identify and handle non-conforming bitstreams. The methods for identifying and handling errors and other such situations are not specified in this document.</t>
        <t>The APV bitstream is described using syntax code based on the C programming language <xref target="ISO9899"/> -- including use of if/else, while, and for -- as well as functions defined within this document.</t>
        <t>The syntax table in syntax code is presented in a two-column format such as shown in <xref target="syntax-examplecode"/>. In this form, the type column provides a type referenced in that same line of syntax code by using the syntax elements processing functions defined in <xref target="syntax-process-func"/>.</t>
        <figure anchor="syntax-examplecode">
          <name>A depiction of type-labeled syntax code for syntax description in this document</name>
          <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
ExampleSyntaxCode(){                                          |
       operations                                             |
       syntax_element                                         | u(n)
}                                                             |]]></artwork>
        </figure>
      </section>
      <section anchor="syntax-func">
        <name>Syntax Functions and Descriptors</name>
        <t>The functions presented in this document are used in the syntactical description. These functions are expressed in terms of the value of a bitstream pointer that indicates the position of the next bit to be read by the decoding process from the bitstream.</t>
        <section anchor="bytealigned">
          <name>byte_aligned()</name>
          <ul spacing="normal">
            <li>
              <t>If the current position in the bitstream is on the last bit of a byte, i.e., the next bit in the bitstream is the first bit in a byte, the return value of byte_aligned() is equal to TRUE.</t>
            </li>
            <li>
              <t>Otherwise, the return value of byte_aligned() is equal to FALSE.</t>
            </li>
          </ul>
        </section>
        <section anchor="moredataintile">
          <name>more_data_in_tile()</name>
          <ul spacing="normal">
            <li>
              <t>If the current position in the i-th tile() syntax structure is less than TileSize[i] in bytes from the beginning of the tile_header() syntax structure of the i-th tile, the return value of more_data_in_tile() is equal to TRUE.</t>
            </li>
            <li>
              <t>Otherwise, the return value of more_data_in_tile() is equal to FALSE.</t>
            </li>
          </ul>
        </section>
        <section anchor="nextbitsn">
          <name>next_bits(n)</name>
          <t>This function provides the next n bits in the bitstream for comparison purposes, without advancing the bitstream pointer.</t>
        </section>
        <section anchor="readbitsn">
          <name>read_bits(n)</name>
          <t>This function indicates that the next n bits from the bitstream are to be read and it advances the bitstream pointer by n bit positions. When n is equal to 0, read_bits(n) is specified to return a value equal to 0 and to not advance the bitstream pointer.</t>
        </section>
        <section anchor="syntax-process-func">
          <name>Syntax Element Processing Functions</name>
          <dl spacing="normal" newline="false">
            <dt>b(8):</dt><dd>byte having any pattern of bit string (8
            bits). The parsing process for this descriptor is specified by the
            return value of the function read_bits(8).</dd>
            <dt>f(n):</dt><dd>fixed-pattern bit string using n bits written
            (from left to right) with the left bit first, i.e., big endian
            format. The parsing process for this descriptor is specified by
            the return value of the function read_bits(n).</dd>
            <dt>u(n):</dt><dd>unsigned integer using n bits. The parsing
            process for this descriptor is specified by the return value of
            the function read_bits(n) interpreted as a binary representation
            of an unsigned integer with the most significant bit written
            first.</dd>
            <dt>h(v):</dt><dd>variable-length entropy coded syntax element
            with the left bit first, i.e., big endian format. The parsing
            process for this descriptor is specified in <xref
            target="process_h"/>.</dd>
          </dl>
        </section>
      </section>
      <section anchor="list-of-syntax-and-semantics">
        <name>List of Syntax and Semantics</name>
        <section anchor="access-unit">
          <name>Access Unit</name>
          <figure anchor="syntaxcode-access_unit">
            <name>access unit syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
access_unit(au_size){                                         |
    signature                                                 | f(32)
    currReadSize = 4                                          |
    do(){                                                     |
        pbu_size                                              | u(32)
        currReadSize += 4                                     |
        pbu()                                                 |
        currReadSize += pbu_size                              |
    } while (au_size > currReadSize)                          |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>signature</dt>
            <dd>A four-character code that identifies the bitstream as an APV AU. The value <bcp14>MUST</bcp14> be 'aPv1' (0x61507631).</dd>
            <dt>pbu_size</dt>
            <dd>the size of a primitive bitstream unit in bytes. A value of 0 is prohibited and the value of 0xFFFFFFFF for pbu_size is reserved for future use.</dd>
          </dl>
          <t>Note: An AU consists of one primary frame, zero or more non-primary frames such as a frame for additional view, zero or more alpha frames, zero or more depth frames, zero or more preview frames such as a frame with smaller resolution, zero or more metadata, and zero or more fillers.</t>
        </section>
        <section anchor="pbu">
          <name>Primitive Bitstream Unit</name>
          <figure anchor="syntaxcode-pbu">
            <name>primitive bitstream unit syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
pbu(){                                                        |
    pbu_header()                                              |
    if((1 <= pbu_type && pbu_type <=2) ||                     |
      (25 <= pbu_type && pbu_type <= 27))                     |
      frame()                                                 |
    else if(pbu_type == 65)                                   |
      au_info()                                               |
    else if(pbu_type == 66)                                   |
      metadata()                                              |
    else if (pbu_type == 67)                                  |
      filler()                                                |
}                                                             |]]></artwork>
          </figure>
        </section>
        <section anchor="pbu-header">
          <name>Primitive Bitstream Unit Header</name>
          <figure anchor="syntaxcode-pbu_header">
            <name>primitive bitstream unit header syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
pbu_header(){                                                 |
    pbu_type                                                  | u(8)
    group_id                                                  | u(16)
    reserved_zero_8bits                                       | u(8)
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>pbu_type</dt>
            <dd><t>indicates the type of data in a PBU listed in <xref
            target="_table-pbu_type"/>. Other values of pbu_type are reserved
            for future use.</t>
          <table anchor="_table-pbu_type">
            <name>List of PBU types</name>
            <thead>
              <tr>
                <th align="center">pbu_type</th>
                <th align="center">meaning</th>
                <th align="center">notes</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">0</td>
                <td align="center">reserved</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">1</td>
                <td align="center">primary frame</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">2</td>
                <td align="center">non-primary frame</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">3...24</td>
                <td align="center">reserved</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">25</td>
                <td align="center">preview frame</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">26</td>
                <td align="center">depth frame</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">27</td>
                <td align="center">alpha frame</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">28...64</td>
                <td align="center">reserved</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">65</td>
                <td align="center">access unit information</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">66</td>
                <td align="center">metadata</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">67</td>
                <td align="center">filler</td>
                <td align="center"> </td>
              </tr>
              <tr>
                <td align="center">68...255</td>
                <td align="center">reserved</td>
                <td align="center"> </td>
              </tr>
            </tbody>
          </table>
              <t>Note: A PBU with pbu_type equal to 65 (access unit information) may happen in an AU. If it exists, it <bcp14>MUST</bcp14> be the first PBU in an AU, and it can be ignored by a decoder.</t>
            </dd>
            <dt>group_id</dt>
            <dd>indicates the identifier to associate a coded frame with metadata. More than two frames can have the same group_id in a single AU. A primary frame and a non-primary frame <bcp14>MUST</bcp14> have different group_id values, and two non-primary frames <bcp14>MUST</bcp14> have different group_id values. When the value of group_id is equal to 0, the value of pbu_type <bcp14>MUST</bcp14> be greater than 64. The value of 0xFFFF for group_id is reserved for future use.</dd>
            <dt>reserved_zero_8bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to the profiles specified in <xref target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are reserved for future use. Decoders conforming to the profiles specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of reserved_zero_8bits greater than 0.</dd>
          </dl>
        </section>
        <section anchor="frame">
          <name>Frame</name>
          <figure anchor="syntaxcode-frame">
            <name>frame() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
frame(){                                                      |
    frame_header()                                            |
    for(i = 0; i < NumTiles; i++){                            |
        tile_size[i]                                          | u(32)
        tile(i)                                               |
    }                                                         |
    filler()                                                  |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>tile_size[i]</dt>
            <dd><t>indicates the size in bytes of i-th tile data (i.e.,
            tile(i)) in raster order in a frame. The value of 0 for
            tile_size[i] is reserved for future use.</t>
            <t>The variable TileSize[i] is set equal to tile_size[i].</t></dd>
          </dl>
        </section>
        <section anchor="frame-header">
          <name>Frame Header</name>
          <figure anchor="syntaxcode-frame_header">
            <name>frame_header() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
frame_header(){                                               |
  frame_info()                                                |
  reserved_zero_8bits                                         | u(8)
  color_description_present_flag                              | u(1)
  if(color_description_present_flag){                         |
    color_primaries                                           | u(8)
    transfer_characteristics                                  | u(8)
    matrix_coefficients                                       | u(8)
    full_range_flag                                           | u(1)
  }                                                           |
  use_q_matrix                                                | u(1)
  if(use_q_matrix){                                           |
    quantization_matrix()                                     |
  }                                                           |
  tile_info()                                                 |
  reserved_zero_8bits                                         | u(8)
  byte_alignment()                                            |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>reserved_zero_8bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to
            the profiles specified in <xref
            target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are
            reserved for future use. Decoders conforming to the profiles
            specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of 
            reserved_zero_8bits greater than 0.</dd>
            <dt>color_description_present_flag equal to 1</dt>
            <dd>specifies that color_primaries, transfer_characteristics, and
            matrix_coefficients are present. color_description_present_flag
            equal to 0 specifies that color_primaries,
            transfer_characteristics, and matrix_coefficients are not
            present.</dd>
            <dt>color_primaries</dt>
            <dd><bcp14>MUST</bcp14> have the semantics of ColourPrimaries as
            specified in <xref target="H273"/>. When the color_primaries
            syntax element is not present, the value of color_primaries is
            inferred to be equal to 2.</dd>
            <dt>transfer_characteristics</dt>
            <dd><bcp14>MUST</bcp14> have the semantics of
            TransferCharacteristics as specified in <xref
            target="H273"/>. When the transfer_characteristics syntax element
            is not present, the value of transfer_characteristics is inferred
            to be equal to 2.</dd>
            <dt>matrix_coefficients</dt>
            <dd><bcp14>MUST</bcp14> have the semantics of MatrixCoefficients
            as specified in <xref target="H273"/>. When the
            matrix_coefficients syntax element is not present, the value of
            matrix_coefficients is inferred to be equal to 2.</dd>
            <dt>full_range_flag</dt>
            <dd><bcp14>MUST</bcp14> have the semantics of VideoFullRangeFlag
            as specified in <xref target="H273"/>. When the full_range_flag
            syntax element is not present, the value of full_range_flag is
            inferred to be equal to 0.</dd>
            <dt>use_q_matrix</dt>
            <dd>with a value of 1 specifies that the quantization matrices are
            present. A value of 0 specifies that the quantization matrices are
            not present.</dd>
            <dt>reserved_zero_8bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to
            the profiles specified in <xref
            target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are
            reserved for future use. Decoders conforming to the profiles
            specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of
            reserved_zero_8bits greater than 0.</dd>
          </dl>
        </section>
        <section anchor="frame-info">
          <name>Frame Information</name>
          <figure anchor="syntaxcode-frame_info">
            <name>frame_info() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
frame_info(){                                                 |
  profile_idc                                                 | u(8)
  level_idc                                                   | u(8)
  band_idc                                                    | u(3)
  reserved_zero_5bits                                         | u(5)
  frame_width                                                 | u(24)
  frame_height                                                | u(24)
  chroma_format_idc                                           | u(4)
  bit_depth_minus8                                            | u(4)
  capture_time_distance                                       | u(8)
  reserved_zero_8bits                                         | u(8)
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>profile_idc</dt>
            <dd>indicates a profile to which the coded frame conforms as
            specified in <xref
            target="appendix-profile-level-band"/>. Bitstreams <bcp14>SHALL
            NOT</bcp14> contain values of profiles_idc other than those
            specified in <xref target="appendix-profile-level-band"/>. Other
            values of profile_idc are reserved for future use.</dd>
            <dt>level_idc</dt>
            <dd>indicates a level to which the coded frame conforms as
            specified in <xref
            target="appendix-profile-level-band"/>. Bitstreams <bcp14>SHALL
            NOT</bcp14> contain values of level_idc other than those specified
            in <xref target="appendix-profile-level-band"/>. Other values of
            level_idc are reserved for future use.</dd>
            <dt>band_idc</dt>
            <dd>specifies a maximum coded data rate of level_idc as specified
            in <xref target="appendix-profile-level-band"/>. Bitstreams
            <bcp14>SHALL NOT</bcp14> contain values of band_idc other than
            those specified in <xref
            target="appendix-profile-level-band"/>. The value of band_idc
            <bcp14>MUST</bcp14> be in the range of 0 to 3. Other values of
            band_idc are reserved for future use.</dd>
            <dt>reserved_zero_5bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to
            the profiles specified in <xref
            target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are
            reserved for future use. Decoders conforming to the profiles
            specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of
            reserved_zero_8bits greater than 0.</dd>
            <dt>frame_width</dt>
            <dd>specifies the width of the frame in units of luma
            samples. frame_width <bcp14>MUST</bcp14> be a multiple of 2 when
            chroma_format_idc has a value of 2. The value 0 is reserved for
            future use.</dd>
            <dt>frame_height</dt>
            <dd>specifies the height of the frame in units of luma samples. The value 0 is reserved for future use.</dd>
            <dt>The variables FrameWidthInMbsY, FrameHeightInMbsY,
            FrameWidthInSamplesY, FrameHeightInSamplesY, FrameWidthInSamplesC,
            FrameHeightInSamplesC, FrameSizeInMbsY, and FrameSizeInSamplesY
            are derived as follows:</dt>
	    <dd>
              <ul spacing="normal">
                <li>FrameWidthInSamplesY = frame_width</li>
                <li>FrameHeightInSamplesY = frame_height</li>
                <li>FrameWidthInMbsY = ceil(FrameWidthInSamplesY / MbWidth)</li>
                <li>FrameHeightInMbsY = ceil(FrameHeightInSamplesY / MbHeight)</li>
                <li>FrameWidthInSamplesC = FrameWidthInSamplesY // SubWidthC</li>
                <li>FrameHeightInSamplesC = FrameHeightInSamplesY // SubHeightC</li>
                <li>FrameSizeInMbsY = FrameWidthInMbsY * FrameHeightInMbsY</li>
                <li>FrameSizeInSamplesY = FrameWidthInSamplesY * FrameHeightInSamplesY</li>
              </ul>
            </dd>
            <dt>chroma_format_idc</dt>
            <dd>specifies the chroma sampling relative to the luma sampling as
            specified in <xref target="_table-chroma_format_idc"/>. The value
            of chroma_format_idc <bcp14>MUST</bcp14> be 0, 2, 3, or 4. Other
            values are reserved for future use.</dd>
            <dt>bit_depth_minus8</dt>
            <dd><t>specifies the bit depth of the samples. The variables BitDepth and QpBdOffset are derived as follows:</t>
            <ul spacing="normal">
              <li>BitDepth = bit_depth_minus8 + 8</li>
              <li>QpBdOffset = bit_depth_minus8 * 6</li>
	    </ul>
            <t>bit_depth_minus8 <bcp14>MUST</bcp14> be in the range of 2 to 8, inclusive. Other values are reserved for future use.</t>
            </dd>
            <dt>capture_time_distance</dt>
            <dd>indicates the time difference between the capture time of the
            frames in the previous access unit and frames in the current
            access unit in milliseconds if there has been any access unit
            preceding the access unit this frame belongs to.</dd>
            <dt>reserved_zero_8bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to
            the profiles specified in <xref
            target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are
            reserved for future use. Decoders conforming to the profiles
            specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of
            reserved_zero_8bits greater than 0.</dd>
          </dl>
        </section>
        <section anchor="quantization-matrix">
          <name>Quantization Matrix</name>
          <figure anchor="syntaxcode-quantization_matrix">
            <name>quantization_matrix() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
quantization_matrix(){                                        |
  for(i = 0; i < NumComps; i++){                              |
    for(y = 0; y < 8; y++){                                   |
      for(x = 0; x < 8; x++){                                 |
        q_matrix[i][x][y]                                     | u(8)
      }                                                       |
    }                                                         |
  }                                                           |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>q_matrix[i][x][y]</dt>
            <dd><t>specifies a scaling value in the quantization matrices. When
            q_matrix[i][x][y] is not present, it is inferred to be equal to
            16. The array index i specifies an indicator for the color
            component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1
            for Cb, and 2 for Cr. The value of 0 for q_matrix[i][x][y] is
            reserved for future use.</t>
            <t>The quantization matrix, QMatrix[i][x][y], is derived as follows:</t>
            <ul spacing="normal">
              <li>QMatrix[i][x][y] = q_matrix[i][x][y]</li>
            </ul>
            </dd>
	  </dl>
        </section>
        <section anchor="tile-info">
          <name>Tile Info</name>
          <figure anchor="syntaxcode-tile_info">
            <name>tile_info() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
tile_info(){                                                  |
  tile_width_in_mbs                                           | u(20)
  tile_height_in_mbs                                          | u(20)
  startMb = 0                                                 |
  for(i = 0; startMb < FrameWidthInMbsY; i++){                |
    ColStarts[i] = startMb * MbWidth                          |
    startMb += tile_width_in_mbs                              |
  }                                                           |
  ColStarts[i] = FrameWidthInMbsY*MbWidth                     |
  TileCols = i                                                |
  startMb = 0                                                 |
  for(i = 0; startMb < FrameHeightInMbsY; i++){               |
    RowStarts[i] = startMb * MbHeight                         |
    startMb += tile_height_in_mbs                             |
  }                                                           |
  RowStarts[i] = FrameHeightInMbsY*MbHeight                   |
  TileRows = i                                                |
  NumTiles = TileCols * TileRows                              |
  tile_size_present_in_fh_flag                                | u(1)
  if(tile_size_present_in_fh_flag){                           |
    for(i = 0; i < NumTiles; i++){                            |
      tile_size_in_fh[i]                                      | u(32)
    }                                                         |
  }                                                           |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>tile_width_in_mbs</dt>
            <dd>specifies the width of a tile in units of MBs.</dd>
            <dt>tile_height_in_mbs</dt>
            <dd>specifies the height of a tile in units of MBs.</dd>
            <dt>tile_size_present_in_fh_flag</dt>
            <dd>equal to 1 specifies that tile_size_in_fh[i] is present in the
            frame header. tile_size_present_in_fh_flag equal to 0 specifies
            that tile_size_in_fh[i] is not present in the frame header.</dd>
            <dt>tile_size_in_fh[i]</dt>
            <dd>indicates the size in bytes of i-th tile data in raster order
            in a frame. The value of tile_size_in_fh[i] <bcp14>MUST</bcp14>
            have the same value with tile_size[i]. When it is not present, the
            value of tile_size_in_fh[i] is inferred to be equal to
            tile_size[i]. The value of 0 for tile_size_in_fh[i] is reserved
            for future use.</dd>
          </dl>
        </section>
        <section anchor="au-info">
          <name>Access Unit Information</name>
          <figure anchor="syntaxcode-au_info">
            <name>au_info() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
au_info(){                                                    |
  num_frames                                                  | u(16)
  for(i = 0; i < num_frames; i++){                            |
    pbu_type                                                  | u(8)
    group_id                                                  | u(16)
    reserved_zero_8bits                                       | u(8)
    frame_info()                                              |
  }                                                           |
  reserved_zero_8bits                                         | u(8)
  byte_alignment()                                            |
  filler()                                                    |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>num_frames</dt>
            <dd>indicates the number of frames contained in the current AU.</dd>
            <dt>pbu_type</dt>
            <dd><t>has the same semantics as pbu_type in the pbu_header() syntax.</t>
	    <t>Note: The value of pbu_type <bcp14>MUST</bcp14> be 1, 2, 25,
	    26, or 27 in bitstreams conforming to this document.</t></dd>
            <dt>group_id</dt>
            <dd>has the same semantics as group_id in the pbu_header() syntax.</dd>
            <dt>reserved_zero_8bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to
            the profiles specified in <xref
            target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are
            reserved for future use. Decoders conforming to the profiles
            specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of
            reserved_zero_8bits greater than 0.</dd>
          </dl>
        </section>
        <section anchor="metadata">
          <name>Metadata</name>
          <figure anchor="syntaxcode-metadata">
            <name>metadata() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata(){                                                   |
  metadata_size                                               | u(32)
  currReadSize = 0                                            |
  do{                                                         |
    payloadType = 0                                           |
    while(next_bits(8) == 0xFF){                              |
      ff_byte                                                 | f(8)
      payloadType += ff_byte                                  |
      currReadSize++                                          |
    }                                                         |
    metadata_payload_type                                     | u(8)
    payloadType += metadata_payload_type                      |
    currReadSize++                                            |
                                                              |
    payloadSize = 0                                           |
    while(next_bits(8) == 0xFF){                              |
      ff_byte                                                 | f(8)
      payloadSize += ff_byte                                  |
      currReadSize++                                          |
    }                                                         |
    metadata_payload_size                                     | u(8)
    payloadSize += metadata_payload_size                      |
    currReadSize++                                            |
                                                              |
    metadata_payload(payloadType, payloadSize)                |
    currReadSize += payloadSize                               |
  } while(metadata_size > currReadSize)                       |
  filler()                                                    |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>metadata_size</dt>
            <dd>specifies the size of metadata before filler() in the current PBU.</dd>
            <dt>ff_byte</dt>
            <dd>is a byte equal to 0xFF.</dd>
            <dt>metadata_payload_type</dt>
            <dd>specifies the last byte of the payload type of a metadata.</dd>
            <dt>metadata_payload_size</dt>
            <dd>specifies the last byte of the payload size of a metadata.</dd>
          </dl>
          <t>Syntax and semantics of metadata_payload() are specified in <xref target="appendix-metadata"/>.</t>
        </section>
        <section anchor="filler">
          <name>Filler</name>
          <figure anchor="syntaxcode-filler">
            <name>filler() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
filler(){                                                     |
  while(next_bits(8) == 0xFF)                                 |
    ff_byte                                                   | f(8)
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>ff_byte</dt>
            <dd>is a byte equal to 0xFF.</dd>
          </dl>
        </section>
        <section anchor="tile">
          <name>Tile</name>
          <figure anchor="syntaxcode-tile">
            <name>tile() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
tile(tileIdx){                                                |
  tile_header(tileIdx)                                        |
  for(i = 0; i < NumComps; i++){                              |
    tile_data(tileIdx, i)                                     |
  }                                                           |
  while(more_data_in_tile()){                                 |
    tile_dummy_byte                                           | b(8)
  }                                                           |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>tile_dummy_byte</dt>
            <dd>has any pattern of 8-bit string.</dd>
          </dl>
        </section>
        <section anchor="tile-header">
          <name>Tile Header</name>
          <figure anchor="syntaxcode-tileheader">
            <name>tile_header() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
tile_header(tileIdx){                                         |
  tile_header_size                                            | u(16)
  tile_index                                                  | u(16)
  for(i = 0; i < NumComps; i++){                              |
    tile_data_size[i]                                         | u(32)
  }                                                           |
  for(i = 0; i < NumComps; i++){                              |
    tile_qp[i]                                                | u(8)
  }                                                           |
  reserved_zero_8bits                                         | u(8)
  byte_alignment()                                            |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>tile_header_size</dt>
            <dd>indicates the size of the tile header in bytes.</dd>
            <dt>tile_index</dt>
            <dd>specifies the tile index in raster order in a frame. tile_index <bcp14>MUST</bcp14> have the same value as tileIdx.</dd>
            <dt>tile_data_size[i]</dt>
            <dd>indicates the size of the i-th color component data in a tile in
            bytes. The array index i specifies an indicator for the color
            component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr.
            The value of 0 for tile_data_size[i] is
            reserved for future use.</dd>
            <dt>tile_qp[i]</dt>
            <dd><t>specifies the quantization parameter value for i-th color
            component. The array index i specifies an indicator for the color
            component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr. The Qp[i] to be used for the MBs in the tile are
            derived as follows:</t>
            <ul spacing="normal">
              <li>Qp[i] = tile_qp[i] - QpBdOffset</li>
              <li>Qp[i] <bcp14>MUST</bcp14> be in the range of -QpBdOffset to 51, inclusive.</li>
            </ul></dd>
            <dt>reserved_zero_8bits</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0 in bitstreams conforming to
            the profiles specified in <xref
            target="appendix-profile-level-band"/>. Values of reserved_zero_8bits greater than 0 are
            reserved for future use. Decoders conforming to the profiles
            specified in <xref target="appendix-profile-level-band"/> <bcp14>MUST</bcp14> ignore PBU with values of
            reserved_zero_8bits greater than 0.</dd>
          </dl>
        </section>
        <section anchor="tile-data">
          <name>Tile Data</name>
          <figure anchor="syntaxcode-tiledata">
            <name>tile_data() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
tile_data(tileIdx, cIdx){                                     |
  x0 = ColStarts[tileIdx % TileCols]                          |
  y0 = RowStarts[tileIdx // TileCols]                         |
  numMbColsInTile = (ColStarts[tileIdx % TileCols + 1] -      |
          ColStarts[tileIdx % TileCols]) // MbWidth           |
  numMbRowsInTile = (RowStarts[tileIdx // TileCols + 1] -     |
          RowStarts[tileIdx // TileCols]) // MbHeight         |
  numMbsInTile = numMbColsInTile * numMbRowsInTile            |
  PrevDC = 0                                                  |
  PrevDcDiff = 20                                             |
  Prev1stAcLevel = 0                                          |
  for(i = 0; i < numMbsInTile; i++){                          |
    xMb = x0 + ((i % numMbColsInTile) * MbWidth)              |
    yMb = y0 + ((i // numMbColsInTile) * MbHeight)            |
    macroblock_layer(xMb, yMb, cIdx)                          |
  }                                                           |
  byte_alignment()                                            |
}                                                             |]]></artwork>
          </figure>
          
          <t>The tile_data() syntax calculates the location of the macroblocks belonging to each tile and collects them.</t>
          
        </section>
        <section anchor="mb-layer">
          <name>Macroblock Layer</name>
          <figure anchor="syntaxcode-macroblock_layer">
            <name>macroblock_layer() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
macroblock_layer(xMb, yMb, cIdx){                             |
  subW = (cIdx == 0)? 1 : SubWidthC                           |
  subH = (cIdx == 0)? 1 : SubHeightC                          |
  blkWidth = (cIdx == 0)? MbWidth : MbWidthC                  |
  blkHeight = (cIdx == 0)? MbHeight : MbHeightC               |
  TrSize = 8                                                  |
  for(y = 0; y < blkHeight; y += TrSize){                     |
    for(x = 0; x < blkWidth; x += TrSize){                    |
      abs_dc_coeff_diff                                       | h(v)
      if(abs_dc_coeff_diff)                                   |
        sign_dc_coeff_diff                                    | u(1)
      TransCoeff[cIdx][xMb // subW + x][yMb // subH + y] =    |
            PrevDC + abs_dc_coeff_diff *                      |
            (1 - 2*sign_dc_coeff_diff)                        |
      PrevDC =                                                |
        TransCoeff[cIdx][xMb // subW + x][yMb // subH + y]    |
      PrevDcDiff = abs_dc_coeff_diff                          |
      ac_coeff_coding(xMb // subW + x, yMb // subH + y,       |
            log2(TrSize), log2(TrSize), cIdx)                 |
    }                                                         |
  }                                                           |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>abs_dc_coeff_diff</dt>
            <dd>specifies the absolute value of the difference between the current DC transform coefficient level and PrevDC.</dd>
            <dt>sign_dc_coeff_diff</dt>
            <dd>specifies the sign of the difference between the current DC
            transform coefficient level and PrevDC. sign_dc_coeff_diff equal
            to 0 specifies that the difference has a positive
            value. sign_dc_coeff_diff equal to 1 specifies that the difference
            has a negative value.</dd>
          </dl>
          <t>The transform coefficients are represented by the arrays TransCoeff[cIdx][x0][y0]. The array indices x0, y0 specify the location (x0, y0) relative to the top-left sample for each component of the frame. The array index cIdx specifies an indicator for the color component; when chroma_format_idc is equal to 2 or 3, the value of the index i is equal to 0 for Y component, 1 for Cb, and 2 for Cr. The value of TransCoeff[cIdx][x0][y0] <bcp14>MUST</bcp14> be in the range of -32768 to 32767, inclusive.</t>
        </section>
        <section anchor="ac-coding">
          <name>AC Coefficient Coding</name>
          <figure anchor="syntaxcode-ac_coeff_coding">
            <name>ac_coeff_coding() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
ac_coeff_coding(x0, y0, log2BlkWidth, log2BlkHeight, cIdx){   |
  scanPos = 1                                                 |
  firstAC = 1                                                 |
  PrevLevel = Prev1stAcLevel                                  |
  PrevRun = 0                                                 |
  do{                                                         |
    coeff_zero_run                                            | h(v)
    for(i = 0; i < coeff_zero_run; i++){                      |
      blkPos = ScanOrder[scanPos]                             |
      xC = blkPos & ((1 << log2BlkWidth) - 1)                 |
      yC = blkPos >> log2BlkWidth                             |
      TransCoeff[cIdx][x0+xC][y0 + yC] = 0                    |
      scanPos++                                               |
    }                                                         |
    PrevRun = coeff_zero_run                                  |
    if(scanPos < (1 << (log2BlkWidth + log2BlkHeight))){      |
      abs_ac_coeff_minus1                                     | h(v)
      sign_ac_coeff                                           | u(1)
      level = (abs_ac_coeff_minus1 + 1) *                     |
        (1 - 2 * sign_ac_coeff)                               |
      blkPos = ScanOrder[scanPos]                             |
      xC = blkPos & ((1 << log2BlkWidth) - 1)                 |
      yC = blkPos >> log2BlkWidth                             |
      TransCoeff[cIdx][x0 + xC][y0 + yC] = level              |
      scanPos++                                               |
      PrevLevel = abs_ac_coeff_minus1 + 1                     |
      if(firstAC == 1){                                       |
        firstAC = 0                                           |
        Prev1stAcLevel = PrevLevel                            |
      }                                                       |
    }                                                         |
  } while(scanPos < (1 << (log2BlkWidth + log2BlkHeight)))    |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>coeff_zero_run</dt>
            <dd>specifies the number of zero-valued transform coefficient
            levels that are located before the position of the next non-zero
            transform coefficient level in a scan of transform coefficient
            levels.</dd>
            <dt>abs_ac_coeff_minus1</dt>
            <dd>plus 1 specifies the absolute value of an AC transform coefficient level at the given scanning position.</dd>
            <dt>sign_ac_coeff</dt>
            <dd>specifies the sign of an AC transform coefficient level for
            the given scanning position. sign_ac_coeff equal to 0 specifies
            that the corresponding AC transform coefficient level has a
            positive value. sign_ac_coeff equal to 1 specifies that the
            corresponding AC transform coefficient level has a negative
            value.</dd>
          </dl>
          <t>The array ScanOrder[sPos] specifies the mapping of the zig-zag scan position sPos, ranging from 0 to (1 &lt;&lt; log2BlkWidth) * (1 &lt;&lt; log2BlkHeight) - 1, inclusive, to a raster scan position rPos. ScanOrder is derived by invoking <xref target="zig-zag"/> with input parameters blkWidth equal to (1 &lt;&lt; log2BlkWidth) and blkHeight equal to (1 &lt;&lt; log2BlkHeight).</t>
        </section>
        <section anchor="byte-alignment">
          <name>Byte Alignment</name>
          <figure anchor="syntaxcode-byte_alignment">
            <name>byte_alignment() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
byte_alignment(){                                             |
  while(!byte_aligned())                                      |
    alignment_bit_equal_to_zero                               | f(1)
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>alignment_bit_equal_to_zero</dt>
            <dd><bcp14>MUST</bcp14> be equal to 0.</dd>
          </dl>
        </section>
      </section>
    </section>
    <section anchor="decoding-process">
      <name>Decoding Process</name>
      <t>This process is invoked to obtain a decoded frame from a bitstream. Input to this process is a bitstream of a coded frame. Output of this process is a decoded frame.</t>
      <t>The decoding process operates as follows for the current frame:</t>
      <ul spacing="normal">
        <li>
          <t>The syntax structure for a coded frame is parsed to obtain the parsed syntax structures.</t>
        </li>
        <li>
          <t>The processes in Sections <xref target="mb-decoding" format="counter"/>, <xref target="block-recon" format="counter"/>, and <xref target="scaling-transform" format="counter"/> specify the decoding processes using syntax elements in all syntax structures. For bitstreams conforming to this document, the coded tiles of the frame <bcp14>MUST</bcp14> contain tile data for every MB of the frame, such that the division of the frame into tiles and the division of the tiles into MBs form a partitioning of the frame.</t>
        </li>
        <li>
          <t>After all the tiles in the current frame have been decoded, the decoded frame is cropped using the cropping rectangle if FrameWidthInSamplesY is not equal to FrameWidthInMbsY * MbWidth or FrameHeightInSamplesY is not equal to FrameHeightInMbsY * MbHeight.</t>
        </li>
        <li>
          <t>The cropping rectangle, which specifies the samples of a frame that are output, is derived as follows:</t>
          <ul spacing="normal">
            <li>
              <t>The cropping rectangle contains the luma samples with horizontal frame coordinates from 0 to FrameWidthInSampleY - 1 and vertical frame coordinates from 0 to FrameHeightInSamplesY - 1, inclusive.</t>
            </li>
            <li>
              <t>The cropping rectangle contains the two chroma arrays having frame coordinates (x//SubWidthC, y//SubHeightC), where (x,y) are the frame coordinates of the specified luma samples.</t>
            </li>
          </ul>
        </li>
      </ul>
      <section anchor="mb-decoding">
        <name>MB Decoding Process</name>
        <t>This process is invoked for each MB.</t>
        <t>Input to this process is a luma location (xMb, yMb) specifying the top-left sample of the current luma MB relative to the top-left luma sample of the current frame.
Outputs of this process are the reconstructed samples of all color components. The total number of color components is indicated by the value of NumComps for the current MB. For example, when chroma_format_idc is equal to 2 or 3, the value of NumComps is equal to 3 and three components, Y component, Cb component, and Cr component, are reconstructed </t>
        <t>The following steps apply:</t>
        <ul spacing="normal">
          <li>
            <t>Let recSamples[0] be a (MbWidth)x(MbHeight) array of the reconstructed samples of the first color component (when chroma_format_idc is equal to 2 or 3, Y).</t>
          </li>
          <li>
            <t>The block reconstruction process as specified in <xref target="block-recon"/> is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidth, the variable nBlkH set equal to MbHeight, the variable cIdx set equal to 0, and the (MbWidth)x(MbHeight) array recSamples[0] as inputs. The output is a modified version of the (MbWidth)x(MbHeight) array recSamples[0], which is the reconstructed samples of the first color component for the current MB.</t>
          </li>
          <li>
        <t>When chroma_format_idc is not equal to 0, let recSamples[1] be a (MbWidthC)x(MbHeightC) array of the reconstructed samples of the second color component. For example, when chroma_format_idc is equal to 2 or 3, recSamples[1] is the Cb color component.</t>
          </li>
          <li>
            <t>When chroma_format_idc is not equal to 0, the block reconstruction process as specified in <xref target="block-recon"/> is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidthC, the variable nBlkH set equal to MbHeightC, the variable cIdx set equal to 1, and the (MbWidthC)x(MbHeightC) array recSamples[1] as inputs.  The output is a modified version of the (MbWidthC)x(MbHeightC) array recSamples[1], which is the reconstructed samples of the second color component for the current MB.</t>
          </li>
          <li>
            <t>When chroma_format_idc is not equal to 0, let recSamples[2] be a (MbWidthC)x(MbHeightC) array of the reconstructed samples of the third color component. For example, when chroma_format_idc is equal to 2 or 3, recSamples[2] is the Cr color component.</t>
          </li>
          <li>
            <t>When chroma_format_idc is not equal to 0, the block reconstruction process as specified in <xref target="block-recon"/> is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidthC, the variable nBlkH set equal to MbHeightC, the variable cIdx set equal to 2, and the (MbWidthC)x(MbHeightC) array recSamples[2] as inputs. The output is a modified version of the (MbWidthC)x(MbHeightC) array recSamples[2], which is the reconstructed samples of the third color component for the current MB.</t>
          </li>
          <li>
            <t>When chroma_format_idc is equal to 4, let recSamples[3] be a (MbWidthC)x(MbHeightC) array of the reconstructed samples of the fourth color component.</t>
          </li>
          <li>
            <t>When chroma_format_idc is equal to 4, the block reconstruction process as specified in <xref target="block-recon"/> is invoked with the luma location (xMb, yMb), the variable nBlkW set equal to MbWidthC, the variable nBlkH set equal to MbHeightC, the variable cIdx set equal to 3, and the (MbWidthC)x(MbHeightC) array recSamples[3] as inputs. The output is a modified version of the (MbWidthC)x(MbHeightC) array recSamples[3], which is the reconstructed samples of the fourth color component for the current MB.</t>
          </li>
        </ul>
      </section>
      <section anchor="block-recon">
        <name>Block Reconstruction Process</name>
        <t>Inputs to this process are:</t>
        <ul spacing="normal">
          <li>
            <t>a luma location (xMb, yMb) specifying the top-left sample of the current MB relative to the top-left luma sample of the current frame,</t>
          </li>
          <li>
            <t>two variables nBlkW and nBlkH specifying the width and the height of the current block,</t>
          </li>
          <li>
            <t>a variable cIdx specifying the color component of the current block, and</t>
          </li>
          <li>
            <t>an (nBlkW)x(nBlkH) array of recSamples of a reconstructed block.</t>
          </li>
        </ul>
        <t>Output of this process is a modified version of the (nBlkW)x(nBlkH) array recSamples of reconstructed samples.</t>
        <t>The following applies:</t>
        <ul spacing="normal">
          <li>
            <t>The variables numBlkX and numBlkY are derived as follows:</t>
            <ul spacing="normal">
              <li>
                <t>numBlkX = nBlkW // TrSize</t>
              </li>
              <li>
                <t>numBlkY = nBlkH // TrSize</t>
              </li>
            </ul>
          </li>    
          <li>
            <t>For yIdx = 0..numBlkY - 1, the following applies:</t>
            <ul spacing="normal">
              <li>
                <t>For xIdx = 0..numBlkX - 1, the following applies:</t>
                <ul spacing="normal">
                  <li>
                    <t>The variables xBlk and yBlk are derived as follows:</t>
                    <ul spacing="normal">
                      <li>
                        <t>xBlk = xMb // (cIdx==0? 1: SubWidthC) + xIdx*TrSize</t>
                      </li>
                      <li>
                        <t>yBlk = yMb // (cIdx==0? 1: SubHeightC) + yIdx*TrSize</t>
                      </li>
                    </ul>  
                  </li>
                  <li>
                    <t>The scaling and transformation process as specified in <xref target="scaling-transform"/> is invoked with the location (xBlk, yBlk), the variable cIdx set equal to cIdx, the transform width nBlkW set equal to TrSize, and the transform height nBlkH set equal to TrSize as inputs. The output is a (TrSize)x(TrSize) array r of a reconstructed block.</t>
                  </li>
                  <li>     
                    <t>The (TrSize)x(TrSize) array recSamples is modified as follows:</t>
                    <ul spacing="normal">
                      <li>   
                        <t>recSamples[(xIdx * TrSize) + i, (yIdx * TrSize) + j] = r[i,j], with i=0..TrSize-1, j=0..TrSize-1</t>
                      </li>
                    </ul>  
                  </li>
                </ul>  
              </li>
            </ul>    
          </li>    
        </ul>  
      </section>
      <section anchor="scaling-transform">
        <name>Scaling and Transformation Process</name>
        <t>Inputs to this process are:</t>
        <ul spacing="normal">
          <li>
            <t>a location (xBlkY, yBlkY) of the current color component specifying the top-left sample of the current block relative to the top-left sample of the current frame,</t>
          </li>
          <li>
            <t>a variable cIdx specifying the color component of the current block,</t>
          </li>
          <li>
            <t>a variable nBlkW specifying the width of the current block, and</t>
          </li>
          <li>
            <t>a variable nBlkH specifying the height of the current block.</t>
          </li>
        </ul>
        <t>Output of this process is the (nBlkW)x(nBlkH) array of reconstructed samples r with elements r[x][y].</t>
        <t>The quantization parameter qP is derived as follows:</t>
        <ul spacing="normal">
          <li>
            <t>qP = Qp[cIdx] + QpBdOffset</t>
          </li>
        </ul>

        <t>The (nBlKW)x(nBlkH) array of reconstructed samples r is derived as follows:</t>
        <ul spacing="normal">
          <li>
            <t>The scaling process for transform coefficients as specified in <xref target="scaling-process"/> is invoked with the block location (xBlkY, yBlkY), the block width nBlkW and the block height nBlkH, the color component variable cIdx, and the quantization parameter qP as inputs. The output is an (nBlkW)x(nBlkH) array of scaled transform coefficients d.</t>
          </li>
          <li>
            <t>The transformation process for scaled transform coefficients as specified in <xref target="process-coeff"/> is invoked with the block location (xBlkY, yBlkY), the block width nBlkW and the block height nBlkH, the color component variable cIdx, and the (nBlkW)x(nBlkH) array of scaled transform coefficients d as inputs. The output is an (nBlkW)x(nBlkH) array of reconstructed samples r.</t>
          </li>
          <li>
            <t>The variable bdShift is derived as follows:</t>
            <ul spacing="normal">
              <li>
                <t>bdShift = 20 - BitDepth</t>
              </li>
            </ul>
          </li>
          <li>
            <t>The reconstructed sample values r[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 are modified as follows:</t>
            <ul spacing="normal">
              <li>
                <t>r[x][y] = clip(0, (1 &lt;&lt; BitDepth)-1, ((r[x][y]+(1 &lt;&lt; (bdShift-1)))&gt;&gt;bdShift) + (1 &lt;&lt; (BitDepth-1)))</t>
              </li>
            </ul>
          </li>
        </ul>
        <section anchor="scaling-process">
          <name>Scaling Process for Transform Coefficients</name>
          <t>Inputs to this process are:</t>
          <ul spacing="normal">
            <li>
              <t>a location (xBlkY, yBlkY) of the current color component specifying the top-left sample of the current block relative to the top-left sample of the current frame,</t>
            </li>
            <li>
              <t>a variable nBlkW specifying the width of the current block,</t>
            </li>
            <li>
              <t>a variable nBlkH specifying the height of the current block,</t>
            </li>
            <li>
              <t>a variable cIdx specifying the color component of the current block, and</t>
            </li>
            <li>
              <t>a variable qP specifying the quantization parameter.</t>
            </li>
          </ul>
          <t>Output of this process is the (nBlkW)x(nBlkH) array d of scaled transform coefficients with elements d[x][y].</t>
          <t>The variable bdShift is derived as follows:</t>
          <ul spacing="normal">
            <li>
              <t>bdShift = BitDepth + ((log2(nBlkW) + log2(nBlkH)) // 2) - 5</t>
            </li>
          </ul>

          <t>The list levelScale[] is specified as follows:</t>
          <ul spacing="normal">
            <li>
              <t>levelScale[k] = {40, 45, 51, 57, 64, 71} with k = 0..5.</t>
            </li>
          </ul>

          <t>For the derivation of the scaled transform coefficients d[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1, the following applies:</t>
          <ul spacing="normal">
            <li>
              <t>The scaled transform coefficient d[x][y] is derived as follows:</t>
              <ul spacing="normal">
                <li>
                  <t>d[x][y] = clip(-32768, 32767, ((TransCoeff[cIdx][xBlkY][yBlkY] * QMatrix[cIdx][x][y] * levelScale[qP % 6] &lt;&lt; (qP//6)) + (1 &lt;&lt; (bdShift-1)) &gt;&gt; bdShift))</t>
                </li>
              </ul>
            </li>
          </ul>

        </section>
        <section anchor="process-coeff">
          <name>Process for Scaled Transform Coefficients</name>
          <section anchor="general-1">
            <name>General</name>
            <t>Inputs to this process are:</t>
            <ul spacing="normal">
              <li>
                <t>a location (xBlkY, yBlkY) of the current color component specifying the top-left sample of the current block relative to the top-left sample of the current frame,</t>
              </li>
              <li>
                <t>a variable nBlkW specifying the width of the current block,</t>
              </li>
              <li>
                <t>a variable nBlkH specifying the height of the current block, and</t>
              </li>
              <li>
                <t>an (nBlkW)x(nBlkH) array d of scaled transform coefficients with elements d[x][y].</t>
              </li>
            </ul>
            <t>Output of this process is the (nBlkW)x(nBlkH) array r of reconstructed samples with elements r[x][y].</t>
            <t>The (nBlkW)x(nBlkH) array r of reconstructed samples is derived as follows:</t>
            <ul spacing="normal">
              <li>
                <t>Each (vertical) column of scaled transform coefficients d[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 is transformed to e[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 by invoking the one-dimensional transformation process as specified in <xref target="transform-process"/> for each column x = 0..nBlkW - 1 with the size of the transform block nBlkH, and the list d[x][y] with y = 0..nBlkH - 1 as inputs. The output is the list e[x][y] with y = 0..nBlkH - 1.</t>
              </li>
              <li>
                <t>The following applies:</t>
                <ul spacing="normal">
                  <li>
                    <t>g[x][y] = (e[x][y] + 64) &gt;&gt; 7</t>
                  </li>
                </ul>
              </li>
              <li>
                <t>Each (horizontal) row of the resulting array g[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 is transformed to r[x][y] with x = 0..nBlkW - 1, y = 0..nBlkH - 1 by invoking the one-dimensional transformation process as specified in <xref target="transform-process"/> for each row y = 0..nBlkH - 1 with the size of the transform block nBlkW, and the list g[x][y] with x = 0..nBlkW - 1 as inputs. The output is the list r[x][y] with x = 0..nBlkW - 1.</t>
              </li>
            </ul>
          </section>
          <section anchor="transform-process">
            <name>Transformation Process</name>
            <t>Inputs to this process are:</t>
            <ul spacing="normal">
              <li>
                <t>a variable nTbS specifying the sample size of scaled transform coefficients, and</t>
              </li>
              <li>
                <t>a list of scaled transform coefficients x with elements x[j], with j = 0..(nTbS - 1).</t>
              </li>
            </ul>
              
            <t>Output of this process is the list of transformed samples y with elements y[i], with i = 0..(nTbS - 1).</t>
            <t>The transformation matrix derivation process as specified in <xref target="matrix-process"/> is invoked with the transform size nTbS as input, and the transformation matrix transMatrix as output.</t>
            <t>The list of transformed samples y[i] with i = 0..(nTbS - 1) is derived as follows:</t>
                <ul spacing="normal">
                  <li>
                    <t>y[i] = sum(j = 0, nTbS - 1, transMatrix[i][j] * x[j])</t>
                  </li>
                </ul>          
          </section>
          <section anchor="matrix-process">
            <name>Transformation Matrix Derivation Process</name>
            <t>Input to this process is a variable nTbS specifying the horizontal sample size of scaled transform coefficients.</t>
            <t>Output of this process is the transformation matrix transMatrix.</t>
            <t>The transformation matrix transMatrix is derived based on nTbs as follows:</t>
            <ul spacing="normal">
              <li>
                <t>If nTbS is equal to 8, the following applies:</t>
            <figure anchor="transmatrix">
              <name>Transform matrix for nTbS == 8</name>
              <artwork><![CDATA[
transMatrix[m][n] =
   {
    {  64,  64,  64,  64,  64,  64,  64,  64 }
    {  89,  75,  50,  18, -18, -50, -75, -89 }
    {  84,  35, -35, -84, -84, -35,  35,  84 }
    {  75, -18, -89, -50,  50,  89,  18, -75 }
    {  64, -64, -64,  64,  64, -64, -64,  64 }
    {  50, -89,  18,  75, -75, -18,  89, -50 }
    {  35, -84,  84, -35, -35,  84, -84,  35 }
    {  18, -50,  75, -89,  89, -75,  50, -18 }
   }]]></artwork>
            </figure>
              </li>
            </ul>
          </section>
        </section>
      </section>
    </section>
    <section anchor="parsing-process">
      <name>Parsing Process</name>
      <section anchor="process_h">
        <name>Process for Syntax Element Type h(v)</name>
        <t>This process is invoked for the parsing of syntax elements with descriptor h(v) in <xref target="mb-layer"/> and <xref target="ac-coding"/>.</t>
        <section anchor="process-for-absdccoeffdiff">
          <name>Process for abs_dc_coeff_diff</name>
          <t>Inputs to this process are bits for the abs_dc_coeff_diff syntax element.
 Output of this process is a value of the abs_dc_coeff_diff syntax element.
 The variable kParam is derived as follows:</t>
            <t indent="3">kParam = clip(0, 5, PrevDcDiff &gt;&gt; 1)</t>
          <t>The value of syntax element abs_dc_coeff_diff is obtained by invoking the parsing process for variable-length codes as specified in <xref target="process-vlc"/> with kParam.</t>
        </section>
        <section anchor="process-for-coeffzerorun">
          <name>Process for coeff_zero_run</name>
          <t>Inputs to this process are bits for the coeff_zero_run syntax element.</t>
          <t>Output of this process is a value of the coeff_zero_run syntax element.</t>
          <t>The variable kParam is derived as follows:</t>
            <t indent="3">kParam = clip(0, 2, PrevRun &gt;&gt; 2)</t>
          <t>The value of syntax element coeff_zero_run is obtained by invoking the parsing process for variable-length codes as specified in <xref target="process-vlc"/> with kParam.</t>
        </section>
        <section anchor="process-for-absaccoeffminus1">
          <name>Process for abs_ac_coeff_minus1</name>
          <t>Inputs to this process are bits for the abs_ac_coeff_minus1 syntax element.</t>
          <t>Output of this process is a value of the abs_ac_coeff_minus1 syntax element.</t>
          <t>The variable kParam is derived as follows:</t>
            <t indent="3">kParam = clip(0, 4, PrevLevel &gt;&gt; 2)</t>
          <t>The value of syntax element abs_ac_coeff_minus1 is obtained by invoking the parsing process for variable-length codes as specified in <xref target="process-vlc"/> with kParam.</t>
        </section>
        <section anchor="process-vlc">
          <name>Process for Variable-Length Codes</name>
          <t>Input to this process is kParam.</t>
          <t>Output of this process is a value, symbolValue, of a syntax element.</t>
          <t>The symbolValue is derived as follows:</t>
          <figure anchor="parse_symbolValue">
            <name>Parsing process of symbolValue</name>
            <artwork><![CDATA[
symbolValue = 0
parseExpGolomb = 1
k = kParam
stopLoop = 0

if(read_bits(1) == 1){
  parseExpGolomb = 0
}
else{
  if(read_bits (1) == 0){
    symbolValue += (1 << k)
    parseExpGolomb = 0
  }
  else{
    symbolValue += (2 << k)
    parseExpGolomb = 1
  }
}

if(parseExpGolomb){
  do{
    if(read_bits(1) == 1){
      stopLoop = 1
    }
    else{
      symbolValue += (1 << k)
      k++
    }
  } while(!stopLoop)
}

if(k > 0)
  symbolValue += read_bits(k)]]></artwork>
          </figure>
          <t>where the value returned from read_bits(n) is interpreted as a binary representation of an n-bit unsigned integer with the most significant bit written first.</t>
        </section>
      </section>
      <section anchor="codeword-generation-process-for-hv-informative">
        <name>Codeword Generation Process for h(v) (Informative)</name>
        <t>This process specifies the code generation process for syntax elements with descriptor h(v).</t>
        <section anchor="process-for-absdccoeffdiff-1">
          <name>Process for abs_dc_coeff_diff</name>
          <t>Input to this process is a symbol value of the abs_dc_coeff_diff syntax element.</t>
          <t>Output of this process is a codeword of the abs_dc_coeff_diff syntax element.</t>
          <t>The variable kParam is derived as follows:</t>
                  <t indent="3">kParam = clip(0, 5, PrevDcDiff &gt;&gt; 1)</t>
          <t>The codeword of syntax element abs_dc_coeff_diff is obtained by invoking the generation process for variable-length codes as specified in <xref target="process-generate-vlc"/> with the symbol value symbolValue and kParam.</t>
        </section>
        <section anchor="process-for-coeffzerorun-1">
          <name>Process for coeff_zero_run</name>
          <t>Input to this process is a symbol value of the coeff_zero_run syntax element.</t>
          <t>Output of this process is a codeword of the coeff_zero_run syntax element.</t>
          <t>The variable kParam is derived as follows:</t>
                  <t indent="3">kParam = clip(0, 2, PrevRun &gt;&gt; 2)</t>
          <t>The codeword of syntax element coeff_zero_run is obtained by invoking the generation process for variable-length codes as specified in <xref target="process-generate-vlc"/> with the symbol value symbolValue and kParam.</t>
        </section>
        <section anchor="process-for-absaccoeffminus1-1">
          <name>Process for abs_ac_coeff_minus1</name>
          <t>Input to this process is a symbol value of the abs_ac_coeff_minus1 syntax element.</t>
          <t>Output of this process is a codeword of the abs_ac_coeff_minus1 syntax element.</t>
          <t>The variable kParam is derived as follows:</t>
                  <t indent="3">kParam = clip(0, 4, PrevLevel &gt;&gt; 2)</t>
          <t>The codeword of syntax element abs_ac_coeff_minus1 is obtained by invoking the generation for variable-length codes as specified in <xref target="process-generate-vlc"/> with the symbol value symbolValue and kParam.</t>
        </section>
        <section anchor="process-generate-vlc">
          <name>Process for Variable-Length Codes</name>
          <t>Inputs to this process are symbolVal and kParam</t>
          <t>Output of this process is a codeword of a syntax element.</t>
          <t>The codeword is derived as follows:</t>
          <figure anchor="gen_symbolValue">
            <name>Generating bits from symbolValue</name>
            <artwork><![CDATA[
PrefixVLCTable[3][2] = {{1, 0}, {0, 0}, {0, 1}}

symbolValue = symbolVal
valPrefixVLC = clip(0, 2, symbolVal >> kParam)
bitCount = 0
k = kParam

while(symbolValue >= (1 << k)){
  symbolValue -= (1 << k)
  if(bitCount < 2)
    put_bits(PrefixVLCTable[valPrefixVLC][bitCount], 1)
  else
    put_bits(0, 1)
  if(bitCount >= 2)
    k++
  bitCount++
}

if(bitCount < 2)
  put_bits(PrefixVLCTable[valPrefixVLC][bitCount], 1)
else
  put_bits(1, 1)

if(k > 0)
  put_bits(symbolValue, k)]]></artwork>
          </figure>
          <t>where a codeword generated from put_bits(v, n) is interpreted as a binary representation of an n-bit unsigned integer value v with the most significant bit written first.</t>
        </section>
      </section>
    </section>
    <section anchor="appendix-metadata">
      <name>Metadata Information</name>
      <section anchor="metadata-payload">
        <name>Metadata Payload</name>
        <figure anchor="syntax-metadatapayload">
          <name>metadata_payload() syntax code</name>

          <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata_payload(payloadType, payloadSize){                   |
  if(payloadType == 4){                                       |
    metadata_itu_t_t35(payloadSize)                           |
  }                                                           |
  else if(payloadType == 5){                                  |
    metadata_mdcv(payloadSize)                                |
  }                                                           |
  else if(payloadType == 6){                                  |
    metadata_cll(payloadSize)                                 |
  }                                                           |
  else if(payloadType == 10){                                 |
    metadata_filler(payloadSize)                              |
  }                                                           |
  else if(payloadType == 170){                                |
    metadata_user_defined(payloadSize)                        |
  }                                                           |
  else{                                                       |
    metadata_undefined(payloadSize)                           |
  }                                                           |
  byte_alignment()                                            |
}                                                             |]]></artwork>
        </figure>
        <t> The syntax and semantics of each type of metadata are defined in <xref target="list-of-metadata-syntax-and-semantics"/>. </t>
      </section>
      <section anchor="list-of-metadata-syntax-and-semantics">
        <name>List of Metadata Syntax and Semantics</name>
        <section anchor="filler-metadata">
          <name>Filler Metadata</name>
          <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata_filler(payloadSize){                                 |
  for(i = 0; i < payloadSize; i++){                           |
    ff_byte                                                   | f(8)
  }                                                           |
}                                                             |]]></artwork>
          <dl spacing="normal" newline="true">
            <dt>ff_byte</dt>
            <dd>is a byte equal to 0xFF.</dd>
          </dl>
        </section>
        <section anchor="recommendation-itu-t-t35-metadata">
          <name>Recommendation ITU-T T.35 Metadata</name>
          <t>This metadata contains information registered as specified in <xref target="ITUT-T35"/>.</t>
          <figure anchor="syntax-metat35">
            <name>metadata_itu_t_t35() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata_itu_t_t35(payloadSize){                              |
  itu_t_t35_country_code                                      | b(8)
  readSize = payloadSize - 1                                  |
                                                              |
  if(itu_t_t35_country_code == 0xFF){                         |
    itu_t_t35_country_code_extension                          | b(8)
    readSize--                                                |
  }                                                           |
                                                              |
  for(i = 0; i < readSize; i++){                              |
    itu_t_t35_payload[i]                                      | b(8)
  }                                                           |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>itu_t_t35_country_code</dt>
            <dd><bcp14>MUST</bcp14> be a byte having the semantics of country code as specified in Annex A of <xref target="ITUT-T35"/>.</dd>
            <dt>itu_t_t35_country_code_extension</dt>
            <dd><bcp14>MUST</bcp14> be a byte having the semantics of country code as specified in Annex B of <xref target="ITUT-T35"/>.</dd>
            <dt>itu_t_t35_payload[i]</dt>
            <dd><bcp14>MUST</bcp14> be a byte having the semantics of data registered as specified in <xref target="ITUT-T35"/>.</dd>
          </dl>
          <t>The terminal provider code and terminal provider oriented code as specified in <xref target="ITUT-T35"/> <bcp14>MUST</bcp14> be contained in the first one or more bytes of the itu_t_t35_payload. Any remaining bytes in itu_t_t35_payload data <bcp14>MUST</bcp14> be data having syntax and semantics as specified by the entity identified by the <xref target="ITUT-T35"/> country code and terminal provider code. Note that any metadata to be carried with this type of payload is expected to have been registered through either national administrator, the Alliance for Telecommunications Industry Solutions (ATIS) or the ITUT-T Telecommunication Standardization Bureau (TSB) as specified in <xref target="ITUT-T35"/>.</t>
        </section>
        <section anchor="mastering-display-color-volume-metadata">
          <name>Mastering Display Color Volume Metadata</name>
          <figure anchor="syntax-metamdcv">
            <name>metadata_mdcv() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata_mdcv(payloadSize){                                   |
  for(i = 0; i < 3; i++){                                     |
    primary_chromaticity_x[i]                                 | u(16)
    primary_chromaticity_y[i]                                 | u(16)
  }                                                           |
  white_point_chromaticity_x                                  | u(16)
  white_point_chromaticity_y                                  | u(16)
  max_mastering_luminance                                     | u(32)
  min_mastering_luminance                                     | u(32)
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>primary_chromaticity_x[i]</dt>
            <dd>specifies a 0.16 fixed-point format of X chromaticity
            coordinate of mastering display in terms of CIE 1931 as specified in <xref target="ISO11664-1"/>, where i =
            0, 1, 2 specifies Red, Green, Blue, respectively.</dd>
            <dt>primary_chromaticity_y[i]</dt>
            <dd>specifies a 0.16 fixed-point format of Y chromaticity
            coordinate of mastering display in terms of CIE 1931 as specified in <xref target="ISO11664-1"/>, where i =
            0, 1, 2 specifies Red, Green, Blue, respectively.</dd>
            <dt>white_point_chromaticity_x</dt>
            <dd>specifies a 0.16 fixed-point format of white point X
            chromaticity coordinate of mastering display in terms of CIE 1931 as specified in <xref target="ISO11664-1"/>.</dd>
            <dt>white_point_chromaticity_y</dt>
            <dd>specifies a 0.16 fixed-point format of white point Y
            chromaticity coordinate as mastering display in terms of CIE 1931 as specified in <xref target="ISO11664-1"/>.</dd>
            <dt>max_mastering_luminance</dt>
            <dd>is a 24.8 fixed-point format of maximum display mastering
            luminance, represented in candelas per square meter.</dd>
            <dt>min_mastering_luminance</dt>
            <dd>is an 18.14 fixed-point format of minimum display mastering
            luminance, represented in candelas per square meter.</dd>
          </dl>
        </section>
        <section anchor="content-light-level-information-metadata">
          <name>Content Light-Level Information Metadata</name>
          <figure anchor="syntax-metatcontentlight">
            <name>metadata_cll() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata_cll(payloadSize){                                    |
  max_cll                                                     | u(16)
  max_fall                                                    | u(16)
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>max_cll</dt>
            <dd>specifies the maximum content light level information as specified in <xref target="CTA-861.3"/>, Appendix A.</dd>
            <dt>max_fall</dt>
            <dd>specifies the maximum frame-average light level information as specified in <xref target="CTA-861.3"/>, Appendix A.</dd>
          </dl>
        </section>
        <section anchor="user-defined-metadata">
          <name>User-Defined Metadata</name>
          <t>This metadata has user data identified by a universal unique identifier as specified in <xref target="RFC9562"/>, the contents of which are not specified in this document.</t>
          <figure anchor="syntax-metauserdef">
            <name>metadata_user_defined() syntax code</name>
            <artwork><![CDATA[
syntax code                                                 | type
------------------------------------------------------------|-----
metadata_user_defined(payloadSize){                         |
  uuid                                                      | u(128)
  for(i = 0; i < (payloadSize - 16); i++)                   |
    user_defined_data_payload[i]                            | b(8)
}                                                           |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>uuid</dt>
            <dd><bcp14>MUST</bcp14> be a 128-bit value specified as a
            generated Universally Unique Identifier (UUID) according to the procedures specified in <xref
            target="RFC9562"/>.</dd>
            <dt>user_defined_data_payload[i]</dt>
            <dd><bcp14>MUST</bcp14> be a byte having user-defined syntax and
            semantics as specified by the UUID generator.</dd>
          </dl>
        </section>
        <section anchor="undefined-metadata">
          <name>Undefined Metadata</name>
          <figure anchor="syntax-metaund">
            <name>metadata_undefined() syntax code</name>
            <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
metadata_undefined(payloadSize){                              |
  for(i = 0; i < payloadSize; i++){                           |
    undefined_metadata_payload_byte[i]                        | b(8)
  }                                                           |
}                                                             |]]></artwork>
          </figure>
          <dl spacing="normal" newline="true">
            <dt>undefined_metadata_payload_byte[i]</dt>
            <dd>is a byte reserved for future use.</dd>
          </dl>
        </section>
      </section>
    </section>
    <section anchor="appendix-profile-level-band">
      <name>Profiles, Levels, and Bands</name>
      <section anchor="overview-of-profiles-levels-and-bands">
        <name>Overview of Profiles, Levels, and Bands</name>
        <t>Profiles, levels, and bands specify restrictions on a coded frame and hence limits on the capabilities needed to decode the coded frame. Profiles, levels, and bands are also used to indicate interoperability points between individual decoder implementations.</t>
        <t>Each profile specifies a subset of algorithmic features and limits that <bcp14>MUST</bcp14> be supported by all decoders conforming to that profile.</t>
            <t indent="3">NOTE: This document does not include individually selectable "options" at the decoder, as this would increase interoperability difficulties.</t>
            <t indent="3">NOTE: Encoders are not required to make use of any particular subset of features supported in a profile.</t>

        <t>Each level with a band specifies a set of limits on the values that may be taken by the syntax elements of this document. For any given profile, a level with a band generally corresponds to a particular decoder processing load and memory capability. The constraints set by levels and bands are orthogonal to the constraints defined by profiles so that the same set of level and band definitions is used with all profiles. For example, a certain level L and a certain band B can be combined with either profile X or profile Y to specifically define two different sets of constraints.</t>
            <t indent="3">NOTE: Individual implementations may support a different level for each supported profile.</t>
      </section>
      <section anchor="requirements-on-video-decoder-capability">
        <name>Requirements on Video Decoder Capability</name>
        <t>Capabilities of video decoders conforming to this document are specified in terms of the ability to decode video streams conforming to the constraints of profiles, levels, and bands specified in this section. When expressing the capabilities of a decoder for a specified profile, the level and the band supported for that profile <bcp14>MUST</bcp14> also be expressed.</t>
        <t>Specific values are specified for the syntax elements profile_idc, level_idc, and band_idc. All other values of profile_idc, level_idc, and band_idc are reserved for future use.</t>

            <t indent="3">NOTE: Decoders <bcp14>SHALL NOT</bcp14> infer that a reserved value of profile_idc between the values specified in this document indicates intermediate capabilities between the specified profiles, as there are no restrictions on the method to be chosen for the use of such future reserved values. However, decoders <bcp14>MUST</bcp14> infer that a reserved value of level_idc and a reserved value of band_idc between the values specified in this document indicates intermediate capabilities between the specified levels.</t>

      </section>
      <section anchor="profiles">
        <name>Profiles</name>
        <section anchor="general-2">
          <name>General</name>
          <t>All constraints for a coded frame that are specified are constraints for the coded frame that are activated when the bitstream of the access unit is decoded.</t>
        </section>
        <section anchor="profile">
          <name>422-10 Profile</name>
          <t>Conformance of a coded frame to the 422-10 profile is indicated by profile_idc equal to 33.</t>
          <t>Coded frames conforming to the 422-10 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be equal to 2.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be equal to 2.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>


          <t>Coded frames conforming to the 422-10 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 422-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 422-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
        <section anchor="profile-1">
          <name>422-12 Profile</name>
          <t>Conformance of a coded frame to the 422-12 profile is indicated by profile_idc equal to 44.</t>
          <t>Coded frames conforming to the 422-12 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be equal to 2.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be in the range of 2 to 4.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>
          <t>Coded frames conforming to the 422-12 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 422-12 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 422-12 profile or the 422-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
        <section anchor="profile-2">
          <name>444-10 Profile</name>
          <t>Conformance of a coded frame to the 444-10 profile is indicated by profile_idc equal to 55.</t>
          <t>Coded frames conforming to the 444-10 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be in the range of 2 to 3.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be equal to 2.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>
          <t>Coded frames conforming to the 444-10 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 444-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 444-10 profile or the 422-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
        <section anchor="profile-3">
          <name>444-12 Profile</name>
          <t>Conformance of a coded frame to the 444-12 profile is indicated by profile_idc equal to 66.</t>
          <t>Coded frames conforming to the 444-12 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be in the range of 2 to 3.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be in the range of 2 to 4.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>
          <t>Coded frames conforming to the 444-12 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 444-12 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 444-12 profile, the 444-10 profile, the 422-12 profile, or the 422-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
        <section anchor="profile-4">
          <name>4444-10 Profile</name>
          <t>Conformance of a coded frame to the 4444-10 profile is indicated by profile_idc equal to 77.</t>
          <t>Coded frames conforming to the 4444-10 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be in the range of 2 to 4.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be equal to 2.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>
          <t>Coded frames conforming to the 4444-10 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 4444-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 4444-10 profile, the 444-10 profile, or the 422-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
        <section anchor="profile-5">
          <name>4444-12 Profile</name>
          <t>Conformance of a coded frame to the 4444-12 profile is indicated by profile_idc equal to 88.</t>
          <t>Coded frames conforming to the 4444-12 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be in the range of 2 to 4.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be in the range of 2 to 4.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>
          <t>Coded frames conforming to the 4444-12 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 4444-12 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 4444-12 profile, the 4444-10 profile, the 444-12 profile, the 444-10 profile, the 422-12 profile, or the 422-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
        <section anchor="profile-6">
          <name>400-10 Profile</name>
          <t>Conformance of a coded frame to the 400-10 profile is indicated by profile_idc equal to 99.</t>
          <t>Coded frames conforming to the 400-10 profile <bcp14>MUST</bcp14> obey the following constraints:</t>
          <ul spacing="normal">
            <li>
              <t>chroma_format_idc <bcp14>MUST</bcp14> be equal to 0.</t>
            </li>
            <li>
              <t>bit_depth_minus8 <bcp14>MUST</bcp14> be equal to 2.</t>
            </li>
            <li>
              <t>pbu_type <bcp14>MUST</bcp14> be equal to 1.</t>
            </li>
          </ul>
          <t>Coded frames conforming to the 400-10 profile <bcp14>MUST</bcp14> also conform to any levels and bands constraints specified in <xref target="levels_and_bands"/>. Decoders conforming to the 400-10 profile at a specific level (identified by a specific value of L) and a specific band (identified by a specific value of B) <bcp14>MUST</bcp14> be capable of decoding all coded frames for which all of the following conditions apply:</t>
          <ul spacing="normal">
            <li>
              <t>The coded frame is indicated to conform to the 400-10 profile.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a level (by a specific value of level_idc) that is lower than or equal to level L.</t>
            </li>
            <li>
              <t>The coded frame is indicated to conform to a band (by a specific value of band_idc) that is lower than or equal to band B.</t>
            </li>
          </ul>
        </section>
      </section>
      <section anchor="levels_and_bands">
        <name>Levels and Bands</name>
        <section anchor="general-3">
          <name>General</name>
          <t>For purposes of comparison of level capabilities, a particular level of each band is considered to be a lower level than some other level when the value of the level_idc of the particular level of each band is less than that of the other level.</t>
          <ul spacing="normal">
            <li>
              <t>The luma sample rate (luma samples per second) <bcp14>MUST</bcp14> be less than or equal to the "Max luma sample rate".</t>
            </li>
            <li>
              <t>The coded data rate (bits per second) <bcp14>MUST</bcp14> be less than or equal to the "Max coded data rate".</t>
            </li>
            <li>
              <t>The value of tile_width_in_mbs <bcp14>MUST</bcp14> be greater than or equal to 16.</t>
            </li>
            <li>
              <t>The value of tile_height_in_mbs <bcp14>MUST</bcp14> be greater than or equal to 8.</t>
            </li>
            <li>
              <t>The value of TileCols <bcp14>MUST</bcp14> be less than or equal to 20.</t>
            </li>
            <li>
              <t>The value of TileRows <bcp14>MUST</bcp14> be less than or equal to 20.</t>
            </li>
          </ul>
        </section>
        <section anchor="limits-of-levels-and-bands">
          <name>Limits of Levels and Bands</name>
          <t><xref target="_table-levels"/> specifies the limits for each level of each band.
A level to which a coded frame conforms is indicated by the syntax elements level_idc and band_idc as follows:</t>
          <ul spacing="normal">
            <li>
              <t>level_idc <bcp14>MUST</bcp14> be set equal to a value of 30 times the level number specified in <xref target="_table-levels"/>.</t>
            </li>
          </ul>
          <table anchor="_table-levels">
            <name>General level limits</name>
            <thead>
              <tr>
                <th align="left" rowspan="3">level</th>
                <th align="center" rowspan="3">Max luma sample rate (samples/s)</th>
                <th align="center" colspan="4">Max coded data rate (Mbit/s)</th>
              </tr>
	      <tr>
		<th align="center" colspan="4">band_idc==</th>
	      </tr>
	      <tr>
                <th align="right">0</th>
                <th align="right">1</th>
                <th align="right">2</th>
                <th align="right">3</th>
	      </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">1</td>
                <td align="right">3,041,280</td>
                <td align="right">8</td>
                <td align="right">11</td>
                <td align="right">15</td>
                <td align="right">23</td>
              </tr>
              <tr>
                <td align="left">1.1</td>
                <td align="right">6,082,560</td>
                <td align="right">16</td>
                <td align="right">21</td>
                <td align="right">30</td>
                <td align="right">45</td>
              </tr>
              <tr>
                <td align="left">2</td>
                <td align="right">15,667,200</td>
                <td align="right">39</td>
                <td align="right">54</td>
                <td align="right">76</td>
                <td align="right">114</td>
              </tr>
              <tr>
                <td align="left">2.1</td>
                <td align="right">31,334,400</td>
                <td align="right">78</td>
                <td align="right">108</td>
                <td align="right">152</td>
                <td align="right">227</td>
              </tr>
              <tr>
                <td align="left">3</td>
                <td align="right">66,846,720</td>
                <td align="right">114</td>
                <td align="right">159</td>
                <td align="right">222</td>
                <td align="right">333</td>
              </tr>
              <tr>
                <td align="left">3.1</td>
                <td align="right">133,693,440</td>
                <td align="right">227</td>
                <td align="right">317</td>
                <td align="right">444</td>
                <td align="right">666</td>
              </tr>
              <tr>
                <td align="left">4</td>
                <td align="right">265,420,800</td>
                <td align="right">455</td>
                <td align="right">637</td>
                <td align="right">892</td>
                <td align="right">1,338</td>
              </tr>
              <tr>
                <td align="left">4.1</td>
                <td align="right">530,841,600</td>
                <td align="right">910</td>
                <td align="right">1,274</td>
                <td align="right">1,784</td>
                <td align="right">2,675</td>
              </tr>
              <tr>
                <td align="left">5</td>
                <td align="right">1,061,683,200</td>
                <td align="right">1,820</td>
                <td align="right">2,548</td>
                <td align="right">3,567</td>
                <td align="right">5,350</td>
              </tr>
              <tr>
                <td align="left">5.1</td>
                <td align="right">2,123,366,400</td>
                <td align="right">3,639</td>
                <td align="right">5,095</td>
                <td align="right">7,133</td>
                <td align="right">10,699</td>
              </tr>
              <tr>
                <td align="left">6</td>
                <td align="right">4,777,574,400</td>
                <td align="right">7,278</td>
                <td align="right">10,189</td>
                <td align="right">14,265</td>
                <td align="right">21,397</td>
              </tr>
              <tr>
                <td align="left">6.1</td>
                <td align="right">8,493,465,600</td>
                <td align="right">14,556</td>
                <td align="right">20,378</td>
                <td align="right">28,529</td>
                <td align="right">42,793</td>
              </tr>
              <tr>
                <td align="left">7</td>
                <td align="right">16,986,931,200</td>
                <td align="right">29,111</td>
                <td align="right">40,756</td>
                <td align="right">57,058</td>
                <td align="right">85,586</td>
              </tr>
              <tr>
                <td align="left">7.1</td>
                <td align="right">33,973,862,400</td>
                <td align="right">58,222</td>
                <td align="right">81,511</td>
                <td align="right">114,115</td>
                <td align="right">171,172</td>
              </tr>
            </tbody>
          </table>
          <t><xref target="_table-level_ex"/> shows widely used typical configurations of resolution and frame rates of video and corresponding levels for them.</t>
          <table anchor="_table-level_ex">
            <name>Example of typical video configurations and corresponding levels (informative)</name>
            <thead>
              <tr>
                <th align="center">use case</th>
                <th align="center">resolution</th>
                <th align="right">frame per second</th>
                <th align="right">luma sample per second</th>
                <th align="left">level</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">720p</td>
                <td align="center">1280 x 720</td>
                <td align="right">30</td>
                <td align="right">27,648,000</td>
                <td align="left">2.1</td>
              </tr>
              <tr>
                <td align="center">FHD</td>
                <td align="center">1920 x 1080</td>
                <td align="right">30</td>
                <td align="right">62,208,000</td>
                <td align="left">3</td>
              </tr>
              <tr>
                <td align="center">UHD 4K</td>
                <td align="center">3840 x 2160</td>
                <td align="right">60</td>
                <td align="right">497,664,000</td>
                <td align="left">4.1</td>
              </tr>
              <tr>
                <td align="center">UHD 4K</td>
                <td align="center">3840 x 2160</td>
                <td align="right">120</td>
                <td align="right">995,328,000</td>
                <td align="left">5</td>
              </tr>
              <tr>
                <td align="center">UHD 8K</td>
                <td align="center">7680 x 4320</td>
                <td align="right">60</td>
                <td align="right">1,990,656,000</td>
                <td align="left">5.1</td>
              </tr>
              <tr>
                <td align="center">UHD 8K</td>
                <td align="center">7680 x 4320</td>
                <td align="right">120</td>
                <td align="right">3,981,312,000</td>
                <td align="left">6</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>Like any other audio or video codec, APV should not be used with insecure ciphers or cipher modes that are vulnerable to known    plaintext attacks.  Some of the header bits as well as the padding are easily predictable.</t>

      <t>A decoder <bcp14>MUST</bcp14> be robust against any non-compliant or malicious payloads. Malicious payloads <bcp14>MUST NOT</bcp14> cause the decoder to overrun its allocated memory or to take an excessive amount of resources to decode. An overrun in allocated memory could lead to arbitrary code execution by an attacker. The same applies to the encoder, even though problems in encoders are typically rare.  Malicious video streams <bcp14>MUST NOT</bcp14> cause the encoder to misbehave because this would allow an attacker to attack transcoding gateways.  A frequent security problem in image and video codecs is failure to check for integer overflows.  An example is allocating "frame_width * frame_height" in pixel count computations without considering that the multiplication result may have overflowed the range of the arithmetic type. The implementation <bcp14>MUST</bcp14> ensure that any data outside of allocated and initialized memory cannot be read.</t>
      <t>A decoder <bcp14>MUST NOT</bcp14> try to process the metadata whose type is not recognized by the implementation. Failure to process any metadata exactly according to the syntax structure specified <bcp14>MAY</bcp14> put a decoder in an unknown status.</t>
      <t>None of the content carried in APV is intended to be executable.</t>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <t>This document has no actions for IANA.</t>
    </section>
  </middle>
  <back>
    <references anchor="sec-combined-references">
      <name>References</name>
      <references anchor="sec-normative-references">
        <name>Normative References</name>
        <reference anchor="H273" target="https://www.itu.int/rec/T-REC-H.273">
          <front>
            <title>Coding-independent code points for video signal type identification</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date year="2024" month="July"/>
          </front>
          <seriesInfo name="ITU-T Recommendation" value="H.273"/>
          <seriesInfo name="ISO/IEC" value="23091-2:2025"/>
        </reference>

        <reference anchor="ISO11664-1" target="https://www.iso.org/standard/74164.html">
          <front>
            <title>Colorimetry - Part 1: CIE standard colorimetric observers</title>
            <author>
              <organization>ISO</organization>
            </author>
            <date year="2019"/>
          </front>
          <seriesInfo name="ISO/CIE" value="11664-1:2019"/>
        </reference>

        <reference anchor="ISO9899" target="https://www.iso.org/standard/82075.html">
          <front>
            <title>Information technology - Programming languages - C</title>
            <author>
              <organization>ISO/IEC</organization>
            </author>
            <date year="2024"/>
          </front>
          <seriesInfo name="ISO/IEC" value="9899:2024"/>
        </reference>

        <reference anchor="ITUT-T35" target="https://www.itu.int/rec/T-REC-T.35">
          <front>
            <title>Procedure for the allocation of ITU-T defined codes for non-standard facilities</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date year="2000" month="February"/>
          </front>
          <seriesInfo name="ITU-T Recommendation" value="T.35"/>
        </reference>

        <reference anchor="CTA-861.3">
          <front>
            <title>HDR Static Metadata Extensions</title>
            <author>
              <organization>CTA</organization>
            </author>
            <date year="2019" month="September"/>
          </front>
<refcontent>CTA-861.3-A</refcontent>
        </reference>
        <reference anchor="CIE15" target="https://cie.co.at/publications/colorimetry-4th-edition">
          <front>
            <title>Colorimetry, 4th Edition</title>
            <author>
              <organization>CIE</organization>
            </author>
            <date year="2018"/>
          </front>
          <seriesInfo name="DOI" value="10.25039/TR.015.2018"/>
        </reference>
         
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9562.xml"/>
      </references>
      <references anchor="sec-informative-references">
        <name>Informative References</name>
        <reference anchor="ASWF" target="https://www.aswf.io/">
          <front>
            <title>The Academy Software Foundation</title>
            <author>
              <organization/>
            </author>
          </front>
        </reference>
        <reference anchor="AMPAS" target="https://www.oscars.org/">
          <front>
            <title>Academy of Motion Picture Arts and Sciences</title>
            <author>
              <organization/>
            </author>
          </front>
        </reference>
        <reference anchor="OpenAPV" target="https://github.com/AcademySoftwareFoundation/openapv">
          <front>
            <title>OpenAPV</title>
            <author>
              <organization/>
            </author>
            <date day="16" month="12" year="2025"/>
          </front>
          <refcontent>commit 1a7845a</refcontent>
        </reference>
        <reference anchor="AOSP16APV" target="https://developer.android.com/about/versions/16/features#apv">
          <front>
            <title>Android open source project version 16</title>
            <author>
              <organization/>
            </author>
          </front>
        </reference>
        <reference anchor="FFmpegAPVdec" target="https://ffmpeg.org/download.html#release_8.0">
          <front>
            <title>FFmpeg implementation of APV decoder</title>
            <author>
              <organization/>
            </author>
            <date day="20" month="November" year="2025"/>
          </front>
        </reference>
        <reference anchor="FFmpegAPVenc" target="https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/fab691edaf53bbf10429ef3448f1f274e5078395">
          <front>
            <title>FFmpeg implementation of APV encoder</title>
            <author>
              <organization/>
            </author>
            <date day="4" month="May" year="2025"/>
          </front>
        </reference>
      </references>
    </references>

      <section anchor="appendix-rawbitstream">
        <name>Raw Bitstream Format</name>
        <figure anchor="syntax-rawbitstream">
          <name>raw_bitstream_access_unit() syntax code</name>
          <artwork><![CDATA[
syntax code                                                   | type
--------------------------------------------------------------|-----
raw_bitstream_access_unit(){                                  |
    au_size                                                   | u(32)
    access_unit(au_size)                                      |
}                                                             |]]></artwork>
        </figure>
        <dl spacing="normal" newline="true">
          <dt>au_size</dt>
          <dd>indicates the size of access unit in bytes. 0 is prohibited and 0xFFFFFFFF is reserved.</dd>
        </dl>
      </section>
      <section anchor="apv-implementations">
        <name>APV Implementations</name>
        <section anchor="openapv-open-source-project">
          <name>OpenAPV Open Source Project</name>
          <t>The Academy Software Foundation (ASWF) <xref target="ASWF"/>, jointly founded  by the Academy of Motion Picture Arts and Science (AMPAS) <xref target="AMPAS"/> and the Linux Foundation, has created an open source software development project conformant to this document <xref target="OpenAPV"/>. The project also provides various test vectors for verification of the implementations at <eref brackets="angle" target="https://github.com/AcademySoftwareFoundation/openapv/tree/main/test/bitstream"/>.</t>
        </section>
        <section anchor="android-open-source-project">
          <name>Android Open Source Project</name>
          <t>The Android open source project (AOSP) has implemented Advanced Professional Video (APV) conformant to this document <xref target="AOSP16APV"/>.</t>
        </section>
        <section anchor="ffmpeg-open-source-project">
          <name>FFmpeg Open Source Project</name>
          <t>The FFmpeg project is developing an APV decoder <xref target="FFmpegAPVdec"/> and an APV encoder <xref target="FFmpegAPVenc"/> conformant to this document.</t>
        </section>
      </section>

  </back>


</rfc>
